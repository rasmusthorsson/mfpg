<!doctype html>
<link rel="stylesheet" type="text/css" href="/mfpg/styles.css">
<script type="text/javascript" src="/mfpg/scripts.js"></script>
<html>
  <head>
    <link rel="stylesheet" href="styles.css">
    <title>MFPG Webpage</title>
  </head>
  <body>
    <div class="topbar">
      <div class="menu">
        <button style="width: 100%;" class="btn">
          <a href="/mfpg/">Home</a>
        </button>
      </div>
      <div class="menu">
        <button style="width: 75%;" class="btn-selected">
          <a href="/mfpg/guides/">Guides</a>
        </button>
        <button onclick="dropGuidesMenu()" class="dropbtn">
          &#11183
        </button>
        <div id="guides" div class="dropdown-menu">
          <div class="dropdown-content">
            <div class="dropdown-text">
              Interfaces
            </div> 
            <a href="/mfpg/guides/guiguide">GUI</a>
            <a href="/mfpg/guides/cliguide">CLI</a>
          </div>
          <div class="dropdown-content">
            <div class="dropdown-text">
              Tools
            </div> 
            <a href="/mfpg/guides/dslguide">DSL</a>
            <a href="/mfpg/guides/notemapbuilder">Notemap Builder</a>
          </div>
          <div class="dropdown-content">
            <div class="dropdown-text">
              Tutorials
            </div> 
            <a href="/mfpg/guides/example-easy">Simple Example</a>
          </div>
        </div>
      </div>

      <div class="menu">
        <button style="width: 75%;" class="btn">
          <a href="/mfpg/links/">Links</a>
        </button>
        <button onclick="dropLinksMenu()" class="dropbtn">
          &#11183
        </button>
        <div id="links" div class="dropdown-menu">
          <div class="dropdown-content">
            <div class="dropdown-text">
              Links
            </div>
            <a href="https://github.com/rasmusthorsson/mfpg">GitHub Repo</a>
          </div>
        </div>
      </div>
      
      <div class="menu">
        <button style="width: 75%;" class="btn">
          <a href="/mfpg/info/">Info</a> 
        </button>
        <button onclick="dropInfoMenu()" class="dropbtn">
          &#11183
        </button>
        <div id="info" div class="dropdown-menu">
          <div class="dropdown-content">
            <div class="dropdown-text">
              Information
            </div>
            <a href="/mfpg/info/patch-notes/">Patch Notes</a>
            <a href="/mfpg/info/faq">Frequently Asked Questions</a>
            <a href="/mfpg/info/issues">Known Issues</a>
            <a href="/mfpg/info/technical-information">Technical Information</a>
          </div>
        </div>
      </div>

    </div>
    <div class="quickbar">
      <div class="quickbar-text">
        Guides
      </div>
        <a href="/mfpg/guides/guiguide">GUI</a>
        <a href="/mfpg/guides/cliguide">CLI</a>
        <a href="/mfpg/guides/dslguide">DSL</a>
        <a href="/mfpg/guides/notemapbuilder">Notemap Builder</a>
        <a href="/mfpg/guides/example-easy" style="color:#a111f1;">Simple Example</a>
    </div>
    <div class="guidepage-index">
      <a href="#Configurations">Configurations</a>
      <a href="#Notemapper">Notemapper</a>
      <a href="#Instrument">Instrument and Actionset</a>
      <a href="#Tidbits">Other Settings</a>
      <a href="#Score" class="inner">Score Selection</a>
      <a href="#Solver" class="inner">Solver Selection</a>
      <a href="#Output" class="inner">Output Selection</a>
      <a href="#Current">Current DSL File</a>
      <a href="#Testing">Testing</a>
      <a href="#Changes">Making changes</a>
      <a href="#Ambiguous" class="inner">Ambiguous actions</a>
      <a href="#Dependencies" class="inner">Dependencies?</a>
      <a href="#Final" class="inner">Final Adjustments</a>
    </div>
    <div class="guidepage">
      <div class="pagetitle">
        A simple example of how to use MFPG
      </div>
      <div class="guidepage-text">
        <h1>Example -- Easy</h1>
        <p>
          In this tutorial we show a simple example of how to use <b>MFPG</b> via the
          <b>GUI</b>. If you would prefer to use the <b>CLI</b>, then this
          tutorial should still be applicable, with the only changes being how the
          different options are selected. For an overview on how these options are
          selected, see the <a href="/mfpg/guides/guiguide">GUI Guide</a> or the
          <a href="/mfpg/guides/cliguide">CLI Guide</a> respectively.
          <br><br>
          For this example we will need three different files, the music
          score in the form of a <b>musicXML</b> file (a file format most notation
          programs allow as export format), the <b>MFPG DSL</b> file, and a
          <b>CSV Notemapper</b> file. These files and their purpose will be explained
          in their respective sections, and in this tutorial we will be using premade
          files taken from the 
          <a href="https://github.com/rasmusthorsson/mfpg">GitHub repo</a>.
        </p>
        <a class="anchor" id="Configurations"></a>
        <h2>Configurations</h2>
        <p>
          When you first launch the <b>MFPG GUI</b>, it looks for a file named
          <i>.mfpg_configs.xml</i> in the current directory. Most likely, this file
          is not present when you first run the program, and you will be asked whether
          you want to create this file in the current directory. This file is used to
          stored information about saved <i>configs</i>. A config is a selection of
          <b>GUI</b> settings, almost any setting you can set in the <b>GUI</b> can 
          be saved as a config. The purpose of configs is to simplify usage when the 
          <b>GUI</b> is restarted or to make it easy to switch between different 
          configs are desired depending on situation. 
          <br><br>
          New configs can be temporarily created in the program
          by using the <i>configs</i> menu at the top of the window, and selected
          in the dropdown bar underneath. Note that creating a new config 
          does <i>not</i> create a new <i>saved</i> config, and any new
          config that is not saved will be deleted when the program is closed.
          If no <i>.mfpg_configs.xml</i> file is found then saving and loading of
          configs is disabled. Temporary configs can be removed by using
          the <i>Remove Config</i> button underneath the config selection.
          However, we will not be working with configs in this tutorial. 
        </p>
        <a class="anchor" id="Notemapper"></a>
        <h2>Notemapper</h2> 
        <p>
          Next we will discuss the <b>Notemapper</b>. The <b>Notemapper</b> is
          a necessary user-defined component of the program which dictates all
          physical <i>ways</i> to play each note on an instrument. This means that
          the <b>Notemapper</b> will specify things like:
          <br><br>
          The <b>A 4</b> Note can be played on the <b>D-String</b> using 
          <b>Finger 2</b> in <b>Hand Position 3</b>
          <br><br>
          However, since almost all notes can be played in multiple different 
          <i>ways</i>, the same <b>Notemapper</b> would also specify:
          <br><br>
          The <b>A 4</b> Note can be played on the <b>A-String</b> using 
          <b>Finger 0</b> in <b>Hand Position 0</b>
          <br><br>
          (Which specifies that <b>A 4</b> can be played on the open <b>A-String</b>)
          <br>
          This is repeated until all <i>ways</i> to play <i>all</i> playable notes
          have been specified. There is no restriction on whether some of the values
          are repeated in different specifications, the same <b>Notemapper</b> could
          also say:
          <br><br>
          The <b>A 4</b> Note can be played on the <b>D-String</b> using 
          <b>Finger 3</b> in <b>Hand Position 2</b>
          <br><br>
          The <b>Notemapper</b> will therefore limit which <i>physical attributes</i>
          can be used in the <b>MFPG DSL</b> (see next section). In these examples, 
          the <i>physical attributes</i> are <b>String</b>, <b>Finger</b>, and <b>
          Hand Position</b>. These are the only attributes available in the premade
          <b>Notemapper</b> we are going to use. 
          <br><br>
          To select this <b>Notemapper</b> we will first need to download the CSV
          file from the <a href="https://github.com/rasmusthorsson/mfpg">Github
        repo</a> found under the <i>'resources/dsl_files/'</i> directory called
        <b>BasicNoteMapper.csv</b>. Alternatively, it can be downloaded by clicking
        <a href="/mfpg/files/BasicNoteMapper.csv" target="_blank">here</a>. This file is
          then used in the <b>GUI</b> by selecting <b>CSV Notemapper</b> under 
          <i>Notemapper Settings</i>, and then selecting the file in the file selector
          <i>CSV File</i> underneath.
        </p>
        <a class="anchor" id="Instrument"></a>
        <h2>Instrument and Actionset</h2>
        <p>
          For this section we will be using the <b>MFPG DSL</b>. In order for the
          program know which notes can be played on which strings of the instrument, 
          it must be told the specifics of the instrument by the user. We must also
          define what is called an <b>Actionset</b> which will contain the
          preferences of the user when it comes to deciding which fingering position
          is superior when there is a choice between multiple fingering positions when
          playing a note. We are going to start with a premade <b>DSL</b> file
          and make some adjustments. In order to get an understanding on how the 
          <b>MFPG DSL</b> files are written and the syntax of the <b>DSL</b> you
          should read the <a href="/mfpg/guides/dslguide">DSL Guide</a>.
          <br><br>
          The <b>DSL</b> file we will use contains a very basic action set, 
          the file can be found in the 
          <a href="https://github.com/rasmusthorsson/mfpg">GitHub repo</a> in the
          <i>'resources/dsl_files/'</i> directory named 
          <b>DSL_test_configuration_1.mfpg
          </b> or be downloaded <a href="/mfpg/files/BasicDSL.mfpg" target="_blank">here
          </a>. Once the file
          has been downloaded the file can be selected by switching the <i>
            Instrument Settings</i> to <i>DSL File</i> and then selecting the file
          in the file selector underneath. Before we make any modifications to 
          the <b>DSL</b> file, let us set up the rest of the
          settings to make it easier to test the modifications we make later on.
        </p>
        <a class="anchor" id="Tidbits"></a>
        <h2>Other Settings</h2>
        <p>
        </p>
        <a class="anchor" id="Score"></a>
        <h3>Score Selection</h3>
        <p>
        We will be using a test case from the 
        <a href="https://github.com/rasmusthorsson/mfpg">GitHub repo</a> found in the
        directory <i>'tests/cases/'</i>, we will use the <b>A_W.xml</b> test case 
        (which can also be downloaded directly 
        <a href="/mfpg/files/A_W.xml" download>here</a>).
        This file can then be selected as a target using the <i>file</i> menu at the
        top of the window. 
        </p>
        <a class="anchor" id="Solver"></a>
        <h3>Solver Selection</h3>
        <p>
        We also have the option of selecting the solver. The only solver that gives a
        correct output out of the two options is the <b>Shortest Path</b> solver, so
        that is the one we are going to use. The two optimization checkboxes should 
        also be used, as they improve performance of the solver.
        </p>
        <a class="anchor" id="Output"></a>
        <h3>Output Selection</h3>
        <p>
        Next, we can select whether we want the output to be written to a file or 
        just written directly to the <i>Output</i> tab in the <i>files</i> window
        in the middle. If a file is selected the file itself will instead be shown in 
        the <i>Output</i> tab. We will not use an output file for this example, so we
        uncheck the <i>Output To File</i> checkbox.
        Finally, we can also select the type of output we want to see, currently only
        two options are available, a CSV output (<i>comma-separated values</i>) or a
        direct output. The direct output is easier to read for a human, so we will
        select that.
        </p>
        <a class="anchor" id="Current"></a>
        <h2>The current state of the DSL file</h2>
        Here is an image of how the program looks like with the current selection.
        <p align="left">
            <img width="600px" height="500px" style="border:2px solid #737373" src="/mfpg/images/example-easy-selection.png">
        </p>
        <p>
        Now we can start considering the <b>DSL</b> file relative to our preferences. 
        We can see
        the <b>DSL</b> file by selecting the <i>DSL tab</i> in the <i>files</i> 
        window, where we can then make changes to the file. Note that no changes are
        made until the file is saved using the buttons at the bottom of the <i>files
        </i> window. Alternatively, this file can be modified using any text-editor
        of your choice if you find it easier to do so, but then you must re-select
        the file using the <b>DSL</b> filepicker to see any new changes in the 
        <i>files</i> window.
        <br><br>
        <i>Section is subject to change as the base DSL file changes over time</i>
        <br><br>
        The first three parts of the <b>DSL</b> file are parts which we will not 
        modify: 
        <ul>
          <li>The output of each action is an integer, the alternative would have it
              be a double value (number with decimals) which is not something we are 
              going to need for this tutorial.
          <li>The attribute 
            declarations specify which attributes may be used in the actions section, 
            we do not want to remove any of these. We also cannot add any more
            attributes since any new additions must also be part of the 
            <b>Notemapper</b>, and the <b>Notemapper</b> we are using for this 
            tutorial only defines those three attributes.</li>
          <li>The instrument declaration, this describes which notes belong to
            which strings on the instrument. Since the <b>Notemapper</b> we are using
            is for the violin, we can not add any new notes here. We are also not
            interested in excluding any existing notes either.</li>
        </ul>
        The <b>DSL</b> file also contains these actions:
        <ul>
          <li>Two actions which define rests, one for going <i>from</i> a rest and one 
              for going <i>to</i> a rest. This allows us to disable all other actions
              if a rest occurs, since we do not need to apply any cost if coming from
              or going to a rest. </li>
          <li>We then have three more actions, one for each of the three attributes, 
              that each apply a cost equivalent to the distance between
              the values of the two attributes across a transition.</li>
          <li>Finally we have a specific action for the <b>String</b> attribute which
              states that if the difference between <b>String</b> values is greater 
              than 1, the cost should be 100. This is done as crossing a string 
              without playing it is something to be avoided at (almost) any cost.
          </li>
        </ul>  
        Finally there is a dependencies part which have a set of dependencies meant to
        achieve two things:
        <ul>
          <li>The first eight dependencies ensure that if the transition is from or
              to a rest, no other actions are considered. This means there is no cost
              associated with transitioning from or to a rest.</li>
          <li>The last dependency defines that if we have a transition that crosses
              more than 1 string, we disable the 'regular' string action and only run
              the 'expensive' string action.
        </ul>
        From these definitions, we can surely make a few improvements and additions to
        build a more effective and accurate actionset.
        </p>
        <a class="anchor" id="Testing"></a>
        <h2>Testing the program</h2>
        While this actionset is not quite what we have in mind for our final setup, 
        we should test out the program before we move on. In order to try it out, 
        we press the <i>'Generate'</i> button. The first couple notes should be 
        generated as below.
        <p align="left">
            <img width="500px" height="400px" style="border:2px solid #737373" src="/mfpg/images/example-easy-first-run.png">
        </p>
        If you want to further validate that your output is correct for this setup,
        you can switch the output to be <i>CSV Output</i>, tick the <i>Output to File
        </i> checkbox, select an output file, generate, and then compare the file with
        <a href="/mfpg/files/A_W_first_test.csv">this</a>.
        </p>
        <a class="anchor" id="Changes"></a>
        <h2>Making some changes</h2>
        <p>
        With the program confirmed to work as intended, we can now look at making some
        changes to the <b>DSL</b> file to improve the output. We have to remember 
        that the output is only <i>right</i> or <i>wrong</i> in relation to the 
        <b>DSL</b> file. The <b>DSL</b> file in turn
        is merely a set of rules on how to evaluate a transition between notes. 
        Therefore, what we want to achieve with the <b>DSL</b> file is a set of rules 
        that mirror the rules <i>we</i> use when we figure out the next fingering 
        position
        manually. This means that writing a <b>DSL</b> file that perfectly represents 
        our own preferences is not trivial, and you will probably not get it 
        completely right on the first attempt. However, this also means that once we 
        arrive at a <b>DSL</b> file that captures our
        preferences very well, we have a very effective tool for easily generating
        new and accurate fingering position sequences.
        </p>
        <a class="anchor" id="Ambiguous"></a>
        <h3>Ambiguous actions</h3>
        <p>
        Let us first consider the three 'regular' actions we have defined, namely the
        three actions <b>HP</b>, <b>FI</b>, and <b>ST</b>. These actions are very 
        simple (they were originally made to faciliate testing, so not much practical
        thought was put into them), and will each probably require modifications.
        The actions are defined using <i>'costs'</i>, but perhaps a more accurate way
        to to view them is <i>'rank'</i> or <i>'severity'</i>. Changing finger is 
        less <i>severe</i> than changing hand position, therefore we would like the
        actions to reflect this. Since the actions <b>FI</b> and <b>HP</b> are 
        currently equal we must change at least one of them. First, let us take a
        look at the finger action:
        <p class="code-p">
        <code>FI = FINGER - FINGER != 0 : FINGER - FINGER (true),</code>
        </p>
        A problem we can see here is that cost increases with the distance of the
        fingers: If we are playing a note using our <i>index finger</i>, and we 
        switch to using our <i>pinky</i>, the cost is 3. If we go from our <i>index
        finger</i> to our <i>middle finger</i> the cost is only 1. Does it make sense
        that the first case is considered more severe than the second case? I think
        they are more or less the same. We can realize this change by changing the 
        distance function of the action to be a constant 1:
        <p class="code-p">
        <code>FI = FINGER - FINGER != 0 : 1 (true),</code>
        </p>
        We also want to remove any ambiguity from when we have the choice between 
        switching to one hand position above or below the current one and switching
        finger. To achieve this we can look at the hand position action:
        <p class="code-p">
        <code>HP = HAND_POS - HAND_POS != 0 : HAND_POS - HAND_POS (true),</code>
        </p>
        Here we are still interested in preserving the scaling severity where the
        cost increases as the difference in hand position gets larger and larger. We
        want to add an additional cost to this to ensure that a hand position switch
        is <i>always</i> more costly than a finger switch. We could do this in at 
        least two ways: We could multiply the already existing cost by two, which
        would have the side-effect of incurring a higher penalty for transitions
        where the hand position shift is large. Alternatively we could add a constant
        1 cost to the hand position cost, which would solve the ambiguity problem 
        without the previously mentioned side-effect. There are probably more
        solutions to this problem, and this is where we have to use our judgement to
        decide which fits our ultimate idea of the <b>DSL</b> file best. Here we are 
        going to go with the second option, and we will deal with large hand
        position transitions with a different action later.
        <p class="code-p">
        <code>HP = HAND_POS - HAND_POS != 0 : HAND_POS - HAND_POS + 1 (true),</code>
        </p>
        </p>
        <a class="anchor" id="Dependencies"></a>
        <h3>Dependencies?</h3>
        <p>
        As discussed in an earlier section, our string action, <b>ST</b>, is only ever
        active if there is a transition where we change from one string to an 
        adjacent string. Generally, switching to an adjacent string should probably
        not incur any cost <i>if</i> we also switch finger, it is more or less the
        same difficulty level as just switching finger. However, if we do 
        <i>not</i> switch finger but also switch string, we might have a situation
        that should incur some cost. To achieve this, we <i>could</i> change the 
        <b>ST</b> action like this:
        <p class="code-p">
        <code>ST = STRING - STRING == 1 && FINGER - FINGER == 0 : 1 (true),</code>
        </p>
        This considers two conditions which must both be true for the cost to be 
        applied: the string value <i>must</i> change by exactly 1, and the finger
        value <i>must not</i> change. There is another way to achieve this using
        dependencies however:
        <p class="code-p">
        <code>N_FI = FINGER - FINGER == 0 : 0 (true),</code>
        <br>
        <code>ST = STRING - STRING == 1 : 1 (false);</code>
        <br>
        <code>ST N_FI true,</code>
        </p>
        Here, we instead factor out the conditions into two independent actions.
        The first says: 
        <br><br>
        <i>If the finger does not change we do nothing.</i>
        <br><br>
        The second says:
        <br><br>
        <i>If the string changes by 1, apply a 1 cost (with the added <b>default 
            condition</b> to <b>not</b> do this).</i>
        <br><br>
        Finally, we state as a <i>dependency</i>: 
        If <b>N_FI</b> occured, then evaluate <b>ST</b>.
        <br><br>
        While the second method might seem more convoluted and less intuitive, it 
        allows for more simplicitly when defining actions, and more flexibility 
        overall. To understand what I mean by this, consider the already existing 
        rest actions, namely <b>REST_F
        </b> and <b>REST_T</b>, we <i>could</i> have used the first method to achieve
        the same effect by not using the dependencies and adding two clauses to 
        <i>each</i>
        other action which checks if the transition was from or to a rest. This would
        bloat the actions however, and even in this simple example we could end up
        with fairly large actions that become increasingly more difficult to reason
        about.
        <br><br>
        Ultimately both methods work. I prefer using the second method and we will
        use that in this tutorial, but it is good to make sure that you understand
        why they both achieve the same thing. For completeness sake we add these 
        two dependencies:
        <p class="code-p">
        <code>N_FI REST_F false,</code>
        <br>
        <code>N_FI REST_T false,</code>
        </p>
        And finally we can remove this dependency: 
        <p class="code-p">
        <code>ST ST_NR true,</code>
        </p>
        As it disables the <b>ST</b> action if the <b>ST_NR</b> action occurs and 
        since these actions are now exclusive, this dependency is no longer needed.
        </p>
        <a class="anchor" id="Final"></a>
        <h3>Final Adjustments</h3>
        <p>
        To finalize our <b>DSL</b> file we will add three more rules, the 
        specifications will be written and the solution hidden so you can attempt 
        them on your own first.
        <br><br>
        As we discussed in a previous section, it might make sense to punish larger
        hand position shifts. We should add a rule for this.
        <h4>Task 1: Add a rule for applying a cost if we shift hand position more
          than 3 positions</h4>
        <div class="hidden">
          <button onclick="dropHiddenTextSol1()" class="hiddenbutton">
            Solution &#11167
          </button>
          <div id="sol-1" class="hiddentext">
            For this rule we want to check the difference in hand positions, this can
            be done in a similar way to how we do it in the <b>HP</b> action. However,
            this time we want to make sure the difference is <i>larger</i> than 3.
            The cost we apply depends on how severely we want to punish this 
            transition, I will use a constant cost of 2:
            <p class="code-p">
            <code>THREE_HP = HAND_POS - HAND_POS > 3 : 2 (true),</code>
            </p>
            This action works in conjunction with the <b>HP</b> action, thus the only
            dependency we need to consider is disabling this new action before or
            after a rest:
            <p class="code-p">
            <code>THREE_HP REST_T false,</code>
            <br>
            <code>THREE_HP REST_F false,</code>
            </p>
          </div>
        </div>
        Next, as the playable area decreases the closer we get to the bridge of the
        violin with our playing hand, one could suggest that there should be a cost 
        associated with higher hand positions.
        <h4>Task 2: Add a rule which applies a cost if the hand position is above 5.
        </h4>
        <div class="hidden">
          <button onclick="dropHiddenTextSol2()" class="hiddenbutton">
            Solution &#11167
          </button>
          <div id="sol-2" class="hiddentext">
            Here we want to check whether the <i>next</i> hand position is greater
            than 5. We do this with the <i>to</i> condition. We then apply a
            constant cost, this will work to attempt to keep the hand position low
            but allow for higher hand positions when there are no good alternatives:
            <p class="code-p">
            <code>HIGH_HP = to HAND_POS > 5 : 3 (true),</code>
            </p>
            Notably, we will not need any dependencies, not even the <b>rest</b> ones 
            we have for all other actions, since the condition is exclusive to
            the <b>REST_T</b> action (they cannot both occur). Additionally if we are 
            transitioning <i>from</i> a rest, we will still want to impose the 
            penalty on a high hand position.
          </div>
        </div>
        We would also like to avoid playing on an open string unless other options
        are very unfeasible. An open string is defined with the attributes: 
        <br><br>
        String = (1-4), Finger = 0, Hand Position = 0.
        <br><br>
        <h4>Task 3: Add a rule which applies a constant cost for transitions to open 
          strings, think about how the open string is represented above. The
          solution for this task should include a few dependencies.</h4>
        <div class="hidden">
          <button onclick="dropHiddenTextSol3()" class="hiddenbutton">
            Solution &#11167
          </button>
          <div id="sol-3" class="hiddentext">
            We will add a check for finger and hand position to check against 0. We
            then add a constant cost of 10, but this is variable based on preference.
            <p class="code-p">
            <code>OPEN_ST = to STRING > 0 && to FINGER == 0 && to HAND_POS == 0 : 10 (true),</code>
            </p>
            The reason for not splitting this action into three actions and binding
            them together with dependencies is that this action is very 
            <i>specific</i> with its definition; individually, these three conditions
            do not make sense, but the combination of the three define this action very
            well.
            <br><br>
            The placement of this action is important, remember that actions are 
            evaluated in the order they are placed, and we want to disable any 
            clashing finger and hand position actions.
            <p class="code-p">
            <code>ST OPEN_ST false,</code>
            <br>
            <code>ST_NR OPEN_ST false,</code>
            <br>
            <code>THREE_HP OPEN_ST false,</code>
            <br>
            <code>HP OPEN_ST false,</code>
            </p>
            This new action must be placed above any of the actions in the above
            dependency declaration. 
          </div>
        </div>
        Finally, we would like to redefine the <b>REST_F</b> and <b>REST_T</b>
        to use <i>definitive</i> attributes rather than the convoluted way of 
        defining a rest by it's exclusive
        <b>PNR</b>:
      <br><br>
      String = 0, Finger = 0, Hand Position = 0.
      <br><br>
      <h4>Task 4: Modify the rest actions to use definitive attributes rather
      than the current setup.</h4>
      </div>
        <div class="hidden">
          <button onclick="dropHiddenTextSol4()" class="hiddenbutton">
            Solution &#11167
          </button>
          <div id="sol-4" class="hiddentext">
            Here we just replace the checks against the physical attributes with one
            check against the type of note.
            <p class="code-p">
            <code>REST_F = this NOTE == REST : 0 (true),</code>
            <br>
            <code>REST_T = to NOTE == REST : 0 (true),</code>
            </p>
            There is no need to alter anything further, thanks to the separation 
            between dependencies and actions.
          </div>
        </div>
        The most important thing for these tasks is to solve the conditions for the
        actions. The costs of the actions are very subjective, and it is for that 
        reason the <b>DSL</b> even exists, to allow each individual to find fingering
        position sequences that fit their preferences. The complete final <b>DSL</b>
        file with all the changes made in this tutorial can be found 
        <a href="/mfpg/files/SimpleExampleDSL.mfpg" target="_blank">here</a>. The output
        (in <b>CSV</b> format, see the <a href="#Testing">Testing the program
        section</a>) when generated with the new DSL file can be found 
        <a href="/mfpg/files/A_W_final_test.csv" target="_blank">here</a>.
        </p>
      </div>
    </div>
  </body>
</html>

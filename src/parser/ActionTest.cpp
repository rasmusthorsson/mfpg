/* File generated by the BNF Converter (bnfc 2.9.5). */

/************************* Compiler Front-End Test *************************/
/*                                                                         */
/*  This test will parse a file, print the abstract syntax tree, and then  */
/*  pretty-print the result.                                               */
/*                                                                         */
/***************************************************************************/

#include <cstdio>
#include <string>
#include <iostream>
#include "Parser.H"
#include "Printer.H"
#include "Absyn.H"
#include "ParserError.H"
/*
#include "ActionBuilder.h"
#include "../ExValException.h"

int TUPLESIZE = 0;
std::string ATTRIBUTE_TYPES;
std::vector<std::string> ATTRIBUTES;
*/
void usage() {
  printf("usage: Call with one of the following argument combinations:\n");
  printf("\t--help\t\tDisplay this help message.\n");
  printf("\t(no arguments)\tParse stdin verbosely.\n");
  printf("\t(files)\t\tParse content of files verbosely.\n");
  printf("\t-s (files)\tSilent mode. Parse content of files silently.\n");
}

int main(int argc, char ** argv)
{
  FILE *input;
  int quiet = 0;
  char *filename = NULL;

  if (argc > 1) {
    if (strcmp(argv[1], "-s") == 0) {
      quiet = 1;
      if (argc > 2) {
        filename = argv[2];
      } else {
        input = stdin;
      }
    } else {
      filename = argv[1];
    }
  }

  if (filename) {
    input = fopen(filename, "r");
    if (!input) {
      usage();
      exit(1);
    }
  } else input = stdin;
  /* The default entry point is used. For other options see Parser.H */
  Input *parse_tree = NULL;
  try {
  parse_tree = pInput(input);
  } catch( parse_error &e) {
     std::cerr << "Parse error on line " << e.getLine() << "\n";
  }
  if (parse_tree)
  {
/*
    ActionBuilder ab;
    ab.visitInput(parse_tree);
   PhysAttrMap p1({ExValContainer(1),
		   ExValContainer(4),
		   ExValContainer(2),
		   ExValContainer(true)});
   
   PhysAttrMap p2({ExValContainer(4),
		   ExValContainer(2),
		   ExValContainer(1),
		   ExValContainer(false)});

   int count = 1;
   for (auto attr : ab.attrs) {
	std::cout << "Attribute " << count << ": " << attr << "\n";
	count++;
   }
   for (auto string : ab.strings) {
	   count = 1;
	   std::cout << "String number: " << string.getPosition() << "\n";
	for (auto note : string.getPlayable()) {
		std::cout << "Note " << count << ": " << note << " ";
		count++;
	}
	std::cout << "\n";
   }
   for (auto action : ab.int_acts) {
	std::cout << "Action: " << action.getID() << "\n";
	std::cout << "Condition: " << action.condition(p1, p2) << "\n";
	std::cout << "Distance: " << action.distance(p1, p2) << "\n";
   }
*/
    printf("\nParse Successful!\n");
    if (!quiet) {
      printf("\n[Abstract Syntax]\n");
      ShowAbsyn *s = new ShowAbsyn();
      printf("%s\n\n", s->show(parse_tree));
      printf("[Linearized Tree]\n");
      PrintAbsyn *p = new PrintAbsyn();
      printf("%s\n\n", p->print(parse_tree));
    }
    delete(parse_tree);
    return 0;
  }
  return 1;
}


/* File generated by the BNF Converter (bnfc 2.9.5). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   BInput    ********************/
BInput::BInput(Output *p1, ListAttrDecl *p2, ListIStr *p3, ListAct *p4)
{
  output_ = p1;
  listattrdecl_ = p2;
  lististr_ = p3;
  listact_ = p4;

}

BInput::BInput(const BInput & other)
{
  output_ = other.output_->clone();
  listattrdecl_ = other.listattrdecl_->clone();
  lististr_ = other.lististr_->clone();
  listact_ = other.listact_->clone();

}

BInput &BInput::operator=(const BInput & other)
{
  BInput tmp(other);
  swap(tmp);
  return *this;
}

void BInput::swap(BInput & other)
{
  std::swap(output_, other.output_);
  std::swap(listattrdecl_, other.listattrdecl_);
  std::swap(lististr_, other.lististr_);
  std::swap(listact_, other.listact_);

}

BInput::~BInput()
{
  delete(output_);
  delete(listattrdecl_);
  delete(lististr_);
  delete(listact_);

}

void BInput::accept(Visitor *v)
{
  v->visitBInput(this);
}

BInput *BInput::clone() const
{
  return new BInput(*this);
}



/********************   DOutput    ********************/
DOutput::DOutput()
{

}

DOutput::DOutput(const DOutput & other)
{

}

DOutput &DOutput::operator=(const DOutput & other)
{
  DOutput tmp(other);
  swap(tmp);
  return *this;
}

void DOutput::swap(DOutput & other)
{

}

DOutput::~DOutput()
{

}

void DOutput::accept(Visitor *v)
{
  v->visitDOutput(this);
}

DOutput *DOutput::clone() const
{
  return new DOutput(*this);
}



/********************   IOutput    ********************/
IOutput::IOutput()
{

}

IOutput::IOutput(const IOutput & other)
{

}

IOutput &IOutput::operator=(const IOutput & other)
{
  IOutput tmp(other);
  swap(tmp);
  return *this;
}

void IOutput::swap(IOutput & other)
{

}

IOutput::~IOutput()
{

}

void IOutput::accept(Visitor *v)
{
  v->visitIOutput(this);
}

IOutput *IOutput::clone() const
{
  return new IOutput(*this);
}



/********************   DAttr    ********************/
DAttr::DAttr(AttrType *p1, Attr *p2)
{
  attrtype_ = p1;
  attr_ = p2;

}

DAttr::DAttr(const DAttr & other)
{
  attrtype_ = other.attrtype_->clone();
  attr_ = other.attr_->clone();

}

DAttr &DAttr::operator=(const DAttr & other)
{
  DAttr tmp(other);
  swap(tmp);
  return *this;
}

void DAttr::swap(DAttr & other)
{
  std::swap(attrtype_, other.attrtype_);
  std::swap(attr_, other.attr_);

}

DAttr::~DAttr()
{
  delete(attrtype_);
  delete(attr_);

}

void DAttr::accept(Visitor *v)
{
  v->visitDAttr(this);
}

DAttr *DAttr::clone() const
{
  return new DAttr(*this);
}



/********************   StringDef    ********************/
StringDef::StringDef(SPos *p1, NoteDef *p2, NoteDef *p3)
{
  spos_ = p1;
  notedef_1 = p2;
  notedef_2 = p3;

}

StringDef::StringDef(const StringDef & other)
{
  spos_ = other.spos_->clone();
  notedef_1 = other.notedef_1->clone();
  notedef_2 = other.notedef_2->clone();

}

StringDef &StringDef::operator=(const StringDef & other)
{
  StringDef tmp(other);
  swap(tmp);
  return *this;
}

void StringDef::swap(StringDef & other)
{
  std::swap(spos_, other.spos_);
  std::swap(notedef_1, other.notedef_1);
  std::swap(notedef_2, other.notedef_2);

}

StringDef::~StringDef()
{
  delete(spos_);
  delete(notedef_1);
  delete(notedef_2);

}

void StringDef::accept(Visitor *v)
{
  v->visitStringDef(this);
}

StringDef *StringDef::clone() const
{
  return new StringDef(*this);
}



/********************   ISPos    ********************/
ISPos::ISPos(Integer p1)
{
  integer_ = p1;

}

ISPos::ISPos(const ISPos & other)
{
  integer_ = other.integer_;

}

ISPos &ISPos::operator=(const ISPos & other)
{
  ISPos tmp(other);
  swap(tmp);
  return *this;
}

void ISPos::swap(ISPos & other)
{
  std::swap(integer_, other.integer_);

}

ISPos::~ISPos()
{

}

void ISPos::accept(Visitor *v)
{
  v->visitISPos(this);
}

ISPos *ISPos::clone() const
{
  return new ISPos(*this);
}



/********************   INote    ********************/
INote::INote(Integer p1)
{
  integer_ = p1;

}

INote::INote(const INote & other)
{
  integer_ = other.integer_;

}

INote &INote::operator=(const INote & other)
{
  INote tmp(other);
  swap(tmp);
  return *this;
}

void INote::swap(INote & other)
{
  std::swap(integer_, other.integer_);

}

INote::~INote()
{

}

void INote::accept(Visitor *v)
{
  v->visitINote(this);
}

INote *INote::clone() const
{
  return new INote(*this);
}



/********************   NNote    ********************/
NNote::NNote(NoteDefBase *p1, Integer p2)
{
  notedefbase_ = p1;
  integer_ = p2;

}

NNote::NNote(const NNote & other)
{
  notedefbase_ = other.notedefbase_->clone();
  integer_ = other.integer_;

}

NNote &NNote::operator=(const NNote & other)
{
  NNote tmp(other);
  swap(tmp);
  return *this;
}

void NNote::swap(NNote & other)
{
  std::swap(notedefbase_, other.notedefbase_);
  std::swap(integer_, other.integer_);

}

NNote::~NNote()
{
  delete(notedefbase_);

}

void NNote::accept(Visitor *v)
{
  v->visitNNote(this);
}

NNote *NNote::clone() const
{
  return new NNote(*this);
}



/********************   NoteDefBase_A    ********************/
NoteDefBase_A::NoteDefBase_A()
{

}

NoteDefBase_A::NoteDefBase_A(const NoteDefBase_A & other)
{

}

NoteDefBase_A &NoteDefBase_A::operator=(const NoteDefBase_A & other)
{
  NoteDefBase_A tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_A::swap(NoteDefBase_A & other)
{

}

NoteDefBase_A::~NoteDefBase_A()
{

}

void NoteDefBase_A::accept(Visitor *v)
{
  v->visitNoteDefBase_A(this);
}

NoteDefBase_A *NoteDefBase_A::clone() const
{
  return new NoteDefBase_A(*this);
}



/********************   NoteDefBase_As    ********************/
NoteDefBase_As::NoteDefBase_As()
{

}

NoteDefBase_As::NoteDefBase_As(const NoteDefBase_As & other)
{

}

NoteDefBase_As &NoteDefBase_As::operator=(const NoteDefBase_As & other)
{
  NoteDefBase_As tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_As::swap(NoteDefBase_As & other)
{

}

NoteDefBase_As::~NoteDefBase_As()
{

}

void NoteDefBase_As::accept(Visitor *v)
{
  v->visitNoteDefBase_As(this);
}

NoteDefBase_As *NoteDefBase_As::clone() const
{
  return new NoteDefBase_As(*this);
}



/********************   NoteDefBase_B    ********************/
NoteDefBase_B::NoteDefBase_B()
{

}

NoteDefBase_B::NoteDefBase_B(const NoteDefBase_B & other)
{

}

NoteDefBase_B &NoteDefBase_B::operator=(const NoteDefBase_B & other)
{
  NoteDefBase_B tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_B::swap(NoteDefBase_B & other)
{

}

NoteDefBase_B::~NoteDefBase_B()
{

}

void NoteDefBase_B::accept(Visitor *v)
{
  v->visitNoteDefBase_B(this);
}

NoteDefBase_B *NoteDefBase_B::clone() const
{
  return new NoteDefBase_B(*this);
}



/********************   NoteDefBase_C    ********************/
NoteDefBase_C::NoteDefBase_C()
{

}

NoteDefBase_C::NoteDefBase_C(const NoteDefBase_C & other)
{

}

NoteDefBase_C &NoteDefBase_C::operator=(const NoteDefBase_C & other)
{
  NoteDefBase_C tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_C::swap(NoteDefBase_C & other)
{

}

NoteDefBase_C::~NoteDefBase_C()
{

}

void NoteDefBase_C::accept(Visitor *v)
{
  v->visitNoteDefBase_C(this);
}

NoteDefBase_C *NoteDefBase_C::clone() const
{
  return new NoteDefBase_C(*this);
}



/********************   NoteDefBase_Cs    ********************/
NoteDefBase_Cs::NoteDefBase_Cs()
{

}

NoteDefBase_Cs::NoteDefBase_Cs(const NoteDefBase_Cs & other)
{

}

NoteDefBase_Cs &NoteDefBase_Cs::operator=(const NoteDefBase_Cs & other)
{
  NoteDefBase_Cs tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_Cs::swap(NoteDefBase_Cs & other)
{

}

NoteDefBase_Cs::~NoteDefBase_Cs()
{

}

void NoteDefBase_Cs::accept(Visitor *v)
{
  v->visitNoteDefBase_Cs(this);
}

NoteDefBase_Cs *NoteDefBase_Cs::clone() const
{
  return new NoteDefBase_Cs(*this);
}



/********************   NoteDefBase_D    ********************/
NoteDefBase_D::NoteDefBase_D()
{

}

NoteDefBase_D::NoteDefBase_D(const NoteDefBase_D & other)
{

}

NoteDefBase_D &NoteDefBase_D::operator=(const NoteDefBase_D & other)
{
  NoteDefBase_D tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_D::swap(NoteDefBase_D & other)
{

}

NoteDefBase_D::~NoteDefBase_D()
{

}

void NoteDefBase_D::accept(Visitor *v)
{
  v->visitNoteDefBase_D(this);
}

NoteDefBase_D *NoteDefBase_D::clone() const
{
  return new NoteDefBase_D(*this);
}



/********************   NoteDefBase_Ds    ********************/
NoteDefBase_Ds::NoteDefBase_Ds()
{

}

NoteDefBase_Ds::NoteDefBase_Ds(const NoteDefBase_Ds & other)
{

}

NoteDefBase_Ds &NoteDefBase_Ds::operator=(const NoteDefBase_Ds & other)
{
  NoteDefBase_Ds tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_Ds::swap(NoteDefBase_Ds & other)
{

}

NoteDefBase_Ds::~NoteDefBase_Ds()
{

}

void NoteDefBase_Ds::accept(Visitor *v)
{
  v->visitNoteDefBase_Ds(this);
}

NoteDefBase_Ds *NoteDefBase_Ds::clone() const
{
  return new NoteDefBase_Ds(*this);
}



/********************   NoteDefBase_E    ********************/
NoteDefBase_E::NoteDefBase_E()
{

}

NoteDefBase_E::NoteDefBase_E(const NoteDefBase_E & other)
{

}

NoteDefBase_E &NoteDefBase_E::operator=(const NoteDefBase_E & other)
{
  NoteDefBase_E tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_E::swap(NoteDefBase_E & other)
{

}

NoteDefBase_E::~NoteDefBase_E()
{

}

void NoteDefBase_E::accept(Visitor *v)
{
  v->visitNoteDefBase_E(this);
}

NoteDefBase_E *NoteDefBase_E::clone() const
{
  return new NoteDefBase_E(*this);
}



/********************   NoteDefBase_F    ********************/
NoteDefBase_F::NoteDefBase_F()
{

}

NoteDefBase_F::NoteDefBase_F(const NoteDefBase_F & other)
{

}

NoteDefBase_F &NoteDefBase_F::operator=(const NoteDefBase_F & other)
{
  NoteDefBase_F tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_F::swap(NoteDefBase_F & other)
{

}

NoteDefBase_F::~NoteDefBase_F()
{

}

void NoteDefBase_F::accept(Visitor *v)
{
  v->visitNoteDefBase_F(this);
}

NoteDefBase_F *NoteDefBase_F::clone() const
{
  return new NoteDefBase_F(*this);
}



/********************   NoteDefBase_Fs    ********************/
NoteDefBase_Fs::NoteDefBase_Fs()
{

}

NoteDefBase_Fs::NoteDefBase_Fs(const NoteDefBase_Fs & other)
{

}

NoteDefBase_Fs &NoteDefBase_Fs::operator=(const NoteDefBase_Fs & other)
{
  NoteDefBase_Fs tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_Fs::swap(NoteDefBase_Fs & other)
{

}

NoteDefBase_Fs::~NoteDefBase_Fs()
{

}

void NoteDefBase_Fs::accept(Visitor *v)
{
  v->visitNoteDefBase_Fs(this);
}

NoteDefBase_Fs *NoteDefBase_Fs::clone() const
{
  return new NoteDefBase_Fs(*this);
}



/********************   NoteDefBase_G    ********************/
NoteDefBase_G::NoteDefBase_G()
{

}

NoteDefBase_G::NoteDefBase_G(const NoteDefBase_G & other)
{

}

NoteDefBase_G &NoteDefBase_G::operator=(const NoteDefBase_G & other)
{
  NoteDefBase_G tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_G::swap(NoteDefBase_G & other)
{

}

NoteDefBase_G::~NoteDefBase_G()
{

}

void NoteDefBase_G::accept(Visitor *v)
{
  v->visitNoteDefBase_G(this);
}

NoteDefBase_G *NoteDefBase_G::clone() const
{
  return new NoteDefBase_G(*this);
}



/********************   NoteDefBase_Gs    ********************/
NoteDefBase_Gs::NoteDefBase_Gs()
{

}

NoteDefBase_Gs::NoteDefBase_Gs(const NoteDefBase_Gs & other)
{

}

NoteDefBase_Gs &NoteDefBase_Gs::operator=(const NoteDefBase_Gs & other)
{
  NoteDefBase_Gs tmp(other);
  swap(tmp);
  return *this;
}

void NoteDefBase_Gs::swap(NoteDefBase_Gs & other)
{

}

NoteDefBase_Gs::~NoteDefBase_Gs()
{

}

void NoteDefBase_Gs::accept(Visitor *v)
{
  v->visitNoteDefBase_Gs(this);
}

NoteDefBase_Gs *NoteDefBase_Gs::clone() const
{
  return new NoteDefBase_Gs(*this);
}



/********************   AttrType_i    ********************/
AttrType_i::AttrType_i()
{

}

AttrType_i::AttrType_i(const AttrType_i & other)
{

}

AttrType_i &AttrType_i::operator=(const AttrType_i & other)
{
  AttrType_i tmp(other);
  swap(tmp);
  return *this;
}

void AttrType_i::swap(AttrType_i & other)
{

}

AttrType_i::~AttrType_i()
{

}

void AttrType_i::accept(Visitor *v)
{
  v->visitAttrType_i(this);
}

AttrType_i *AttrType_i::clone() const
{
  return new AttrType_i(*this);
}



/********************   AttrType_d    ********************/
AttrType_d::AttrType_d()
{

}

AttrType_d::AttrType_d(const AttrType_d & other)
{

}

AttrType_d &AttrType_d::operator=(const AttrType_d & other)
{
  AttrType_d tmp(other);
  swap(tmp);
  return *this;
}

void AttrType_d::swap(AttrType_d & other)
{

}

AttrType_d::~AttrType_d()
{

}

void AttrType_d::accept(Visitor *v)
{
  v->visitAttrType_d(this);
}

AttrType_d *AttrType_d::clone() const
{
  return new AttrType_d(*this);
}



/********************   AttrType_b    ********************/
AttrType_b::AttrType_b()
{

}

AttrType_b::AttrType_b(const AttrType_b & other)
{

}

AttrType_b &AttrType_b::operator=(const AttrType_b & other)
{
  AttrType_b tmp(other);
  swap(tmp);
  return *this;
}

void AttrType_b::swap(AttrType_b & other)
{

}

AttrType_b::~AttrType_b()
{

}

void AttrType_b::accept(Visitor *v)
{
  v->visitAttrType_b(this);
}

AttrType_b *AttrType_b::clone() const
{
  return new AttrType_b(*this);
}



/********************   FunList    ********************/
FunList::FunList(ActionName *p1, CFun *p2, DFun *p3)
{
  actionname_ = p1;
  cfun_ = p2;
  dfun_ = p3;

}

FunList::FunList(const FunList & other)
{
  actionname_ = other.actionname_->clone();
  cfun_ = other.cfun_->clone();
  dfun_ = other.dfun_->clone();

}

FunList &FunList::operator=(const FunList & other)
{
  FunList tmp(other);
  swap(tmp);
  return *this;
}

void FunList::swap(FunList & other)
{
  std::swap(actionname_, other.actionname_);
  std::swap(cfun_, other.cfun_);
  std::swap(dfun_, other.dfun_);

}

FunList::~FunList()
{
  delete(actionname_);
  delete(cfun_);
  delete(dfun_);

}

void FunList::accept(Visitor *v)
{
  v->visitFunList(this);
}

FunList *FunList::clone() const
{
  return new FunList(*this);
}



/********************   AName    ********************/
AName::AName(String p1)
{
  string_ = p1;

}

AName::AName(const AName & other)
{
  string_ = other.string_;

}

AName &AName::operator=(const AName & other)
{
  AName tmp(other);
  swap(tmp);
  return *this;
}

void AName::swap(AName & other)
{
  std::swap(string_, other.string_);

}

AName::~AName()
{

}

void AName::accept(Visitor *v)
{
  v->visitAName(this);
}

AName *AName::clone() const
{
  return new AName(*this);
}



/********************   CombDist    ********************/
CombDist::CombDist(DFun *p1, Exp *p2, DFun *p3)
{
  dfun_1 = p1;
  exp_ = p2;
  dfun_2 = p3;

}

CombDist::CombDist(const CombDist & other)
{
  dfun_1 = other.dfun_1->clone();
  exp_ = other.exp_->clone();
  dfun_2 = other.dfun_2->clone();

}

CombDist &CombDist::operator=(const CombDist & other)
{
  CombDist tmp(other);
  swap(tmp);
  return *this;
}

void CombDist::swap(CombDist & other)
{
  std::swap(dfun_1, other.dfun_1);
  std::swap(exp_, other.exp_);
  std::swap(dfun_2, other.dfun_2);

}

CombDist::~CombDist()
{
  delete(dfun_1);
  delete(exp_);
  delete(dfun_2);

}

void CombDist::accept(Visitor *v)
{
  v->visitCombDist(this);
}

CombDist *CombDist::clone() const
{
  return new CombDist(*this);
}



/********************   ScaledDist    ********************/
ScaledDist::ScaledDist(Attr *p1, Exp *p2, Attr *p3, Scale *p4, Num *p5)
{
  attr_1 = p1;
  exp_ = p2;
  attr_2 = p3;
  scale_ = p4;
  num_ = p5;

}

ScaledDist::ScaledDist(const ScaledDist & other)
{
  attr_1 = other.attr_1->clone();
  exp_ = other.exp_->clone();
  attr_2 = other.attr_2->clone();
  scale_ = other.scale_->clone();
  num_ = other.num_->clone();

}

ScaledDist &ScaledDist::operator=(const ScaledDist & other)
{
  ScaledDist tmp(other);
  swap(tmp);
  return *this;
}

void ScaledDist::swap(ScaledDist & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(exp_, other.exp_);
  std::swap(attr_2, other.attr_2);
  std::swap(scale_, other.scale_);
  std::swap(num_, other.num_);

}

ScaledDist::~ScaledDist()
{
  delete(attr_1);
  delete(exp_);
  delete(attr_2);
  delete(scale_);
  delete(num_);

}

void ScaledDist::accept(Visitor *v)
{
  v->visitScaledDist(this);
}

ScaledDist *ScaledDist::clone() const
{
  return new ScaledDist(*this);
}



/********************   DirectDist    ********************/
DirectDist::DirectDist(Attr *p1, Exp *p2, Attr *p3)
{
  attr_1 = p1;
  exp_ = p2;
  attr_2 = p3;

}

DirectDist::DirectDist(const DirectDist & other)
{
  attr_1 = other.attr_1->clone();
  exp_ = other.exp_->clone();
  attr_2 = other.attr_2->clone();

}

DirectDist &DirectDist::operator=(const DirectDist & other)
{
  DirectDist tmp(other);
  swap(tmp);
  return *this;
}

void DirectDist::swap(DirectDist & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(exp_, other.exp_);
  std::swap(attr_2, other.attr_2);

}

DirectDist::~DirectDist()
{
  delete(attr_1);
  delete(exp_);
  delete(attr_2);

}

void DirectDist::accept(Visitor *v)
{
  v->visitDirectDist(this);
}

DirectDist *DirectDist::clone() const
{
  return new DirectDist(*this);
}



/********************   ConstDist    ********************/
ConstDist::ConstDist(Num *p1)
{
  num_ = p1;

}

ConstDist::ConstDist(const ConstDist & other)
{
  num_ = other.num_->clone();

}

ConstDist &ConstDist::operator=(const ConstDist & other)
{
  ConstDist tmp(other);
  swap(tmp);
  return *this;
}

void ConstDist::swap(ConstDist & other)
{
  std::swap(num_, other.num_);

}

ConstDist::~ConstDist()
{
  delete(num_);

}

void ConstDist::accept(Visitor *v)
{
  v->visitConstDist(this);
}

ConstDist *ConstDist::clone() const
{
  return new ConstDist(*this);
}



/********************   CombCond    ********************/
CombCond::CombCond(CFun *p1, BoolOp *p2, CFun *p3)
{
  cfun_1 = p1;
  boolop_ = p2;
  cfun_2 = p3;

}

CombCond::CombCond(const CombCond & other)
{
  cfun_1 = other.cfun_1->clone();
  boolop_ = other.boolop_->clone();
  cfun_2 = other.cfun_2->clone();

}

CombCond &CombCond::operator=(const CombCond & other)
{
  CombCond tmp(other);
  swap(tmp);
  return *this;
}

void CombCond::swap(CombCond & other)
{
  std::swap(cfun_1, other.cfun_1);
  std::swap(boolop_, other.boolop_);
  std::swap(cfun_2, other.cfun_2);

}

CombCond::~CombCond()
{
  delete(cfun_1);
  delete(boolop_);
  delete(cfun_2);

}

void CombCond::accept(Visitor *v)
{
  v->visitCombCond(this);
}

CombCond *CombCond::clone() const
{
  return new CombCond(*this);
}



/********************   CompCond    ********************/
CompCond::CompCond(Attr *p1, Exp *p2, Attr *p3, CompOp *p4, Num *p5)
{
  attr_1 = p1;
  exp_ = p2;
  attr_2 = p3;
  compop_ = p4;
  num_ = p5;

}

CompCond::CompCond(const CompCond & other)
{
  attr_1 = other.attr_1->clone();
  exp_ = other.exp_->clone();
  attr_2 = other.attr_2->clone();
  compop_ = other.compop_->clone();
  num_ = other.num_->clone();

}

CompCond &CompCond::operator=(const CompCond & other)
{
  CompCond tmp(other);
  swap(tmp);
  return *this;
}

void CompCond::swap(CompCond & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(exp_, other.exp_);
  std::swap(attr_2, other.attr_2);
  std::swap(compop_, other.compop_);
  std::swap(num_, other.num_);

}

CompCond::~CompCond()
{
  delete(attr_1);
  delete(exp_);
  delete(attr_2);
  delete(compop_);
  delete(num_);

}

void CompCond::accept(Visitor *v)
{
  v->visitCompCond(this);
}

CompCond *CompCond::clone() const
{
  return new CompCond(*this);
}



/********************   ValueCond    ********************/
ValueCond::ValueCond(Attr *p1, CompOp *p2, Num *p3)
{
  attr_ = p1;
  compop_ = p2;
  num_ = p3;

}

ValueCond::ValueCond(const ValueCond & other)
{
  attr_ = other.attr_->clone();
  compop_ = other.compop_->clone();
  num_ = other.num_->clone();

}

ValueCond &ValueCond::operator=(const ValueCond & other)
{
  ValueCond tmp(other);
  swap(tmp);
  return *this;
}

void ValueCond::swap(ValueCond & other)
{
  std::swap(attr_, other.attr_);
  std::swap(compop_, other.compop_);
  std::swap(num_, other.num_);

}

ValueCond::~ValueCond()
{
  delete(attr_);
  delete(compop_);
  delete(num_);

}

void ValueCond::accept(Visitor *v)
{
  v->visitValueCond(this);
}

ValueCond *ValueCond::clone() const
{
  return new ValueCond(*this);
}



/********************   BoolCond    ********************/
BoolCond::BoolCond(Bool *p1)
{
  bool_ = p1;

}

BoolCond::BoolCond(const BoolCond & other)
{
  bool_ = other.bool_->clone();

}

BoolCond &BoolCond::operator=(const BoolCond & other)
{
  BoolCond tmp(other);
  swap(tmp);
  return *this;
}

void BoolCond::swap(BoolCond & other)
{
  std::swap(bool_, other.bool_);

}

BoolCond::~BoolCond()
{
  delete(bool_);

}

void BoolCond::accept(Visitor *v)
{
  v->visitBoolCond(this);
}

BoolCond *BoolCond::clone() const
{
  return new BoolCond(*this);
}



/********************   AttrCond    ********************/
AttrCond::AttrCond(Attr *p1)
{
  attr_ = p1;

}

AttrCond::AttrCond(const AttrCond & other)
{
  attr_ = other.attr_->clone();

}

AttrCond &AttrCond::operator=(const AttrCond & other)
{
  AttrCond tmp(other);
  swap(tmp);
  return *this;
}

void AttrCond::swap(AttrCond & other)
{
  std::swap(attr_, other.attr_);

}

AttrCond::~AttrCond()
{
  delete(attr_);

}

void AttrCond::accept(Visitor *v)
{
  v->visitAttrCond(this);
}

AttrCond *AttrCond::clone() const
{
  return new AttrCond(*this);
}



/********************   EAttr    ********************/
EAttr::EAttr(String p1)
{
  string_ = p1;

}

EAttr::EAttr(const EAttr & other)
{
  string_ = other.string_;

}

EAttr &EAttr::operator=(const EAttr & other)
{
  EAttr tmp(other);
  swap(tmp);
  return *this;
}

void EAttr::swap(EAttr & other)
{
  std::swap(string_, other.string_);

}

EAttr::~EAttr()
{

}

void EAttr::accept(Visitor *v)
{
  v->visitEAttr(this);
}

EAttr *EAttr::clone() const
{
  return new EAttr(*this);
}



/********************   Eq    ********************/
Eq::Eq()
{

}

Eq::Eq(const Eq & other)
{

}

Eq &Eq::operator=(const Eq & other)
{
  Eq tmp(other);
  swap(tmp);
  return *this;
}

void Eq::swap(Eq & other)
{

}

Eq::~Eq()
{

}

void Eq::accept(Visitor *v)
{
  v->visitEq(this);
}

Eq *Eq::clone() const
{
  return new Eq(*this);
}



/********************   NEq    ********************/
NEq::NEq()
{

}

NEq::NEq(const NEq & other)
{

}

NEq &NEq::operator=(const NEq & other)
{
  NEq tmp(other);
  swap(tmp);
  return *this;
}

void NEq::swap(NEq & other)
{

}

NEq::~NEq()
{

}

void NEq::accept(Visitor *v)
{
  v->visitNEq(this);
}

NEq *NEq::clone() const
{
  return new NEq(*this);
}



/********************   Gt    ********************/
Gt::Gt()
{

}

Gt::Gt(const Gt & other)
{

}

Gt &Gt::operator=(const Gt & other)
{
  Gt tmp(other);
  swap(tmp);
  return *this;
}

void Gt::swap(Gt & other)
{

}

Gt::~Gt()
{

}

void Gt::accept(Visitor *v)
{
  v->visitGt(this);
}

Gt *Gt::clone() const
{
  return new Gt(*this);
}



/********************   Lt    ********************/
Lt::Lt()
{

}

Lt::Lt(const Lt & other)
{

}

Lt &Lt::operator=(const Lt & other)
{
  Lt tmp(other);
  swap(tmp);
  return *this;
}

void Lt::swap(Lt & other)
{

}

Lt::~Lt()
{

}

void Lt::accept(Visitor *v)
{
  v->visitLt(this);
}

Lt *Lt::clone() const
{
  return new Lt(*this);
}



/********************   Gte    ********************/
Gte::Gte()
{

}

Gte::Gte(const Gte & other)
{

}

Gte &Gte::operator=(const Gte & other)
{
  Gte tmp(other);
  swap(tmp);
  return *this;
}

void Gte::swap(Gte & other)
{

}

Gte::~Gte()
{

}

void Gte::accept(Visitor *v)
{
  v->visitGte(this);
}

Gte *Gte::clone() const
{
  return new Gte(*this);
}



/********************   Lte    ********************/
Lte::Lte()
{

}

Lte::Lte(const Lte & other)
{

}

Lte &Lte::operator=(const Lte & other)
{
  Lte tmp(other);
  swap(tmp);
  return *this;
}

void Lte::swap(Lte & other)
{

}

Lte::~Lte()
{

}

void Lte::accept(Visitor *v)
{
  v->visitLte(this);
}

Lte *Lte::clone() const
{
  return new Lte(*this);
}



/********************   And    ********************/
And::And()
{

}

And::And(const And & other)
{

}

And &And::operator=(const And & other)
{
  And tmp(other);
  swap(tmp);
  return *this;
}

void And::swap(And & other)
{

}

And::~And()
{

}

void And::accept(Visitor *v)
{
  v->visitAnd(this);
}

And *And::clone() const
{
  return new And(*this);
}



/********************   Or    ********************/
Or::Or()
{

}

Or::Or(const Or & other)
{

}

Or &Or::operator=(const Or & other)
{
  Or tmp(other);
  swap(tmp);
  return *this;
}

void Or::swap(Or & other)
{

}

Or::~Or()
{

}

void Or::accept(Visitor *v)
{
  v->visitOr(this);
}

Or *Or::clone() const
{
  return new Or(*this);
}



/********************   CInt    ********************/
CInt::CInt(Integer p1)
{
  integer_ = p1;

}

CInt::CInt(const CInt & other)
{
  integer_ = other.integer_;

}

CInt &CInt::operator=(const CInt & other)
{
  CInt tmp(other);
  swap(tmp);
  return *this;
}

void CInt::swap(CInt & other)
{
  std::swap(integer_, other.integer_);

}

CInt::~CInt()
{

}

void CInt::accept(Visitor *v)
{
  v->visitCInt(this);
}

CInt *CInt::clone() const
{
  return new CInt(*this);
}



/********************   CDouble    ********************/
CDouble::CDouble(Double p1)
{
  double_ = p1;

}

CDouble::CDouble(const CDouble & other)
{
  double_ = other.double_;

}

CDouble &CDouble::operator=(const CDouble & other)
{
  CDouble tmp(other);
  swap(tmp);
  return *this;
}

void CDouble::swap(CDouble & other)
{
  std::swap(double_, other.double_);

}

CDouble::~CDouble()
{

}

void CDouble::accept(Visitor *v)
{
  v->visitCDouble(this);
}

CDouble *CDouble::clone() const
{
  return new CDouble(*this);
}



/********************   ESub    ********************/
ESub::ESub()
{

}

ESub::ESub(const ESub & other)
{

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{

}

ESub::~ESub()
{

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EPlus    ********************/
EPlus::EPlus()
{

}

EPlus::EPlus(const EPlus & other)
{

}

EPlus &EPlus::operator=(const EPlus & other)
{
  EPlus tmp(other);
  swap(tmp);
  return *this;
}

void EPlus::swap(EPlus & other)
{

}

EPlus::~EPlus()
{

}

void EPlus::accept(Visitor *v)
{
  v->visitEPlus(this);
}

EPlus *EPlus::clone() const
{
  return new EPlus(*this);
}



/********************   SMul    ********************/
SMul::SMul()
{

}

SMul::SMul(const SMul & other)
{

}

SMul &SMul::operator=(const SMul & other)
{
  SMul tmp(other);
  swap(tmp);
  return *this;
}

void SMul::swap(SMul & other)
{

}

SMul::~SMul()
{

}

void SMul::accept(Visitor *v)
{
  v->visitSMul(this);
}

SMul *SMul::clone() const
{
  return new SMul(*this);
}



/********************   VTrue    ********************/
VTrue::VTrue()
{

}

VTrue::VTrue(const VTrue & other)
{

}

VTrue &VTrue::operator=(const VTrue & other)
{
  VTrue tmp(other);
  swap(tmp);
  return *this;
}

void VTrue::swap(VTrue & other)
{

}

VTrue::~VTrue()
{

}

void VTrue::accept(Visitor *v)
{
  v->visitVTrue(this);
}

VTrue *VTrue::clone() const
{
  return new VTrue(*this);
}



/********************   VFalse    ********************/
VFalse::VFalse()
{

}

VFalse::VFalse(const VFalse & other)
{

}

VFalse &VFalse::operator=(const VFalse & other)
{
  VFalse tmp(other);
  swap(tmp);
  return *this;
}

void VFalse::swap(VFalse & other)
{

}

VFalse::~VFalse()
{

}

void VFalse::accept(Visitor *v)
{
  v->visitVFalse(this);
}

VFalse *VFalse::clone() const
{
  return new VFalse(*this);
}




/********************   ListAttrDecl    ********************/

void ListAttrDecl::accept(Visitor *v)
{
  v->visitListAttrDecl(this);
}

ListAttrDecl *ListAttrDecl::clone() const
{
  return new ListAttrDecl(*this);
}

ListAttrDecl* consListAttrDecl(AttrDecl* x, ListAttrDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListIStr    ********************/

void ListIStr::accept(Visitor *v)
{
  v->visitListIStr(this);
}

ListIStr *ListIStr::clone() const
{
  return new ListIStr(*this);
}

ListIStr* consListIStr(IStr* x, ListIStr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAct    ********************/

void ListAct::accept(Visitor *v)
{
  v->visitListAct(this);
}

ListAct *ListAct::clone() const
{
  return new ListAct(*this);
}

ListAct* consListAct(Act* x, ListAct* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}






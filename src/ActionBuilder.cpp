/* File generated by the BNF Converter (bnfc 2.9.5). */

/*** Visitor Design Pattern ActionBuilder. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "ActionBuilder.h"
#include <iostream>

extern int TUPLESIZE;
extern std::string ATTRIBUTE_TYPES;
extern std::vector<std::string> ATTRIBUTES;

void ActionBuilder::visitInput(Input *t) {
	t->accept(this);
} //abstract class
void ActionBuilder::visitOutput(Output *t) {} //abstract class
void ActionBuilder::visitAttrDecl(AttrDecl *t) {} //abstract class
void ActionBuilder::visitIStr(IStr *t) {} //abstract class
void ActionBuilder::visitSPos(SPos *t) {} //abstract class
void ActionBuilder::visitNote(Note *t) {} //abstract class
void ActionBuilder::visitNoteBase(NoteBase *t) {} //abstract class
void ActionBuilder::visitAttrType(AttrType *t) {} //abstract class
void ActionBuilder::visitAct(Act *t) {} //abstract class
void ActionBuilder::visitActionName(ActionName *t) {} //abstract class
void ActionBuilder::visitDFun(DFun *t) {} //abstract class
void ActionBuilder::visitCFun(CFun *t) {} //abstract class
void ActionBuilder::visitAttr(Attr *t) {} //abstract class
void ActionBuilder::visitCompOp(CompOp *t) {} //abstract class
void ActionBuilder::visitBoolOp(BoolOp *t) {} //abstract class
void ActionBuilder::visitNum(Num *t) {} //abstract class
void ActionBuilder::visitExp(Exp *t) {} //abstract class
void ActionBuilder::visitScale(Scale *t) {} //abstract class
void ActionBuilder::visitBool(Bool *t) {} //abstract class

void ActionBuilder::visitBInput(BInput *b_input)
{
  /* Code For BInput Goes Here */

  if (b_input->output_) b_input->output_->accept(this);
  if (b_input->listattrdecl_) b_input->listattrdecl_->accept(this);
  if (b_input->lististr_) b_input->lististr_->accept(this);
  if (b_input->listact_) b_input->listact_->accept(this);

}

void ActionBuilder::visitDOutput(DOutput *d_output)
{
  /* Code For DOutput Goes Here */
	output = 'd';
}

void ActionBuilder::visitIOutput(IOutput *i_output)
{
  /* Code For IOutput Goes Here */
	output = 'i';
}

void ActionBuilder::visitDAttr(DAttr *d_attr)
{
  /* Code For DAttr Goes Here */

  if (d_attr->attrtype_) d_attr->attrtype_->accept(this);
  if (d_attr->attr_) d_attr->attr_->accept(this);
  attrs.push_back(str);
  TUPLESIZE++;
  ATTRIBUTES.push_back(str);
}

void ActionBuilder::visitStringDef(StringDef *string_def)
{
  /* Code For StringDef Goes Here */

  if (string_def->spos_) string_def->spos_->accept(this);
  int spos = integer;
  if (string_def->note_1) string_def->note_1->accept(this);
  noteenums::Note first = note;
  if (string_def->note_2) string_def->note_2->accept(this);
  noteenums::Note second = note;

  IString new_string(spos, first, second);
  strings.push_back(new_string);
}

void ActionBuilder::visitISPos(ISPos *is_pos)
{
  /* Code For ISPos Goes Here */

  visitInteger(is_pos->integer_);

}

void ActionBuilder::visitINote(INote *i_note)
{
  /* Code For INote Goes Here */

  visitInteger(i_note->integer_);

}

void ActionBuilder::visitNNote(NNote *n_note)
{
  /* Code For NNote Goes Here */

  visitInteger(n_note->integer_);
  if (n_note->notebase_) n_note->notebase_->accept(this);

}

void ActionBuilder::visitNoteBase_A(NoteBase_A *note_base_a)
{
  /* Code For NoteBase_A Goes Here */
	note = static_cast<noteenums::Note>(9 + (12 * integer));

}

void ActionBuilder::visitNoteBase_As(NoteBase_As *note_base_as)
{
  /* Code For NoteBase_As Goes Here */
	note = static_cast<noteenums::Note>(10 + (12 * integer));


}

void ActionBuilder::visitNoteBase_B(NoteBase_B *note_base_b)
{
  /* Code For NoteBase_B Goes Here */
	note = static_cast<noteenums::Note>(11 + (12 * integer));


}

void ActionBuilder::visitNoteBase_C(NoteBase_C *note_base_c)
{
  /* Code For NoteBase_C Goes Here */
	note = static_cast<noteenums::Note>(0 + (12 * integer));

}

void ActionBuilder::visitNoteBase_Cs(NoteBase_Cs *note_base_cs)
{
  /* Code For NoteBase_Cs Goes Here */
	note = static_cast<noteenums::Note>(1 + (12 * integer));


}

void ActionBuilder::visitNoteBase_D(NoteBase_D *note_base_d)
{
  /* Code For NoteBase_D Goes Here */
	note = static_cast<noteenums::Note>(2 + (12 * integer));


}

void ActionBuilder::visitNoteBase_Ds(NoteBase_Ds *note_base_ds)
{
  /* Code For NoteBase_Ds Goes Here */
	note = static_cast<noteenums::Note>(3 + (12 * integer));


}

void ActionBuilder::visitNoteBase_E(NoteBase_E *note_base_e)
{
  /* Code For NoteBase_E Goes Here */
	note = static_cast<noteenums::Note>(4 + (12 * integer));


}

void ActionBuilder::visitNoteBase_F(NoteBase_F *note_base_f)
{
  /* Code For NoteBase_F Goes Here */
	note = static_cast<noteenums::Note>(5 + (12 * integer));


}

void ActionBuilder::visitNoteBase_Fs(NoteBase_Fs *note_base_fs)
{
  /* Code For NoteBase_Fs Goes Here */
	note = static_cast<noteenums::Note>(6 + (12 * integer));


}

void ActionBuilder::visitNoteBase_G(NoteBase_G *note_base_g)
{
  /* Code For NoteBase_G Goes Here */
	note = static_cast<noteenums::Note>(7 + (12 * integer));
}

void ActionBuilder::visitNoteBase_Gs(NoteBase_Gs *note_base_gs)
{
  /* Code For NoteBase_Gs Goes Here */
	note = static_cast<noteenums::Note>(8 + (12 * integer));
}

void ActionBuilder::visitAttrType_i(AttrType_i *attr_type_i)
{
  /* Code For AttrType_i Goes Here */
	attrtypes += "i";
	ATTRIBUTE_TYPES += "i";
}

void ActionBuilder::visitAttrType_d(AttrType_d *attr_type_d)
{
  /* Code For AttrType_d Goes Here */
	attrtypes += "d";
	ATTRIBUTE_TYPES += "d";
}

void ActionBuilder::visitAttrType_b(AttrType_b *attr_type_b)
{
  /* Code For AttrType_b Goes Here */
	attrtypes += "b";
	ATTRIBUTE_TYPES += "b";
}

void ActionBuilder::visitFunList(FunList *fun_list)
{
  /* Code For FunList Goes Here */

  if (fun_list->actionname_) fun_list->actionname_->accept(this);
  	std::string action_name = str;
	if (output == 'i') {
		Action<int> a(action_name);
		int_acts.push_back(a);
	} else if (output == 'd') {
		Action<double> a(action_name);
		dub_acts.push_back(a);
	}

  if (fun_list->cfun_) fun_list->cfun_->accept(this);
  if (fun_list->dfun_) fun_list->dfun_->accept(this);

}

void ActionBuilder::visitAName(AName *a_name)
{
  /* Code For AName Goes Here */

  
  visitString(a_name->string_);

}

void ActionBuilder::visitCombDist(CombDist *comb_dist)
{
  /* Code For CombDist Goes Here */

  if (comb_dist->dfun_1) comb_dist->dfun_1->accept(this);
  if (comb_dist->exp_) comb_dist->exp_->accept(this);
  //TODO Add expression between conditions here.
  if (comb_dist->dfun_2) comb_dist->dfun_2->accept(this);

}

void ActionBuilder::visitScaledDist(ScaledDist *scaled_dist)
{
  /* Code For ScaledDist Goes Here */

  if (scaled_dist->attr_1) scaled_dist->attr_1->accept(this);
  std::string attr1 = str;
  if (scaled_dist->exp_) scaled_dist->exp_->accept(this);
  if (scaled_dist->attr_2) scaled_dist->attr_2->accept(this);
  std::string attr2 = str;
  if (scaled_dist->scale_) scaled_dist->scale_->accept(this);
  std::function<exp_fun> scale = e_fun;
  if (scaled_dist->num_) scaled_dist->num_->accept(this);
  if (output == 'i') {
	int num = integer;
	std::function<int_link> current_link = i_link;
	std::function<distfun_int> dfun = [=, this](PhysAttrMap t1, PhysAttrMap t2) -> int {
		return (current_link(num, (abs ((int) scale(t1.getVal(attr1), t2.getVal(attr2))))));	
	};
	int_acts.back().addDistFun(dfun);
  } else if (output == 'd') {
	std::function<dub_link> current_link = d_link;
	int num = dub;
	std::function<distfun_dub> dfun = [=, this](PhysAttrMap t1, PhysAttrMap t2) -> double {
		return (current_link(num, (abs ((double) scale(t1.getVal(attr1), t2.getVal(attr2))))));	
	};
	dub_acts.back().addDistFun(dfun);
  }
	
}

void ActionBuilder::visitDirectDist(DirectDist *direct_dist)
{
  /* Code For DirectDist Goes Here */

  if (direct_dist->attr_1) direct_dist->attr_1->accept(this);
  std::string attr1 = str;
  if (direct_dist->attr_2) direct_dist->attr_2->accept(this);
  std::string attr2 = str; 
  if (direct_dist->exp_) direct_dist->exp_->accept(this);
  if (output == 'i') {
	std::function<distfun_int> dfun = [=, this](PhysAttrMap t1, PhysAttrMap t2) -> int {
		return (abs ((int) e_fun(t1.getVal(attr1), t2.getVal(attr2))));	
	};
	int_acts.back().addDistFun(dfun);
  } else if (output == 'd') {
	std::function<distfun_dub> dfun = [=, this](PhysAttrMap t1, PhysAttrMap t2) -> double {
		return (abs ((double) e_fun(t1.getVal(attr1), t2.getVal(attr2))));	
	};
	dub_acts.back().addDistFun(dfun);
  }
}

void ActionBuilder::visitConstDist(ConstDist *const_dist)
{
  /* Code For ConstDist Goes Here */

  if (const_dist->num_) const_dist->num_->accept(this);
  if (output == 'i') {
  	int num = integer;
	std::function<distfun_int> dfun = [=, this](PhysAttrMap t1, PhysAttrMap t2) -> int {
		return num;	
	};
	int_acts.back().addDistFun(dfun);
  } else if (output == 'd') {
  	double num = dub;
	std::function<distfun_dub> dfun = [=, this](PhysAttrMap t1, PhysAttrMap t2) -> double {
		return num;	
	};
	dub_acts.back().addDistFun(dfun);
  }


}

void ActionBuilder::visitCombCond(CombCond *comb_cond)
{
  /* Code For CombCond Goes Here */

  if (comb_cond->cfun_1) comb_cond->cfun_1->accept(this);
  if (comb_cond->boolop_) comb_cond->boolop_->accept(this);
  //TODO Add boolean joins between CFuns here.
  if (comb_cond->cfun_2) comb_cond->cfun_2->accept(this);

}

void ActionBuilder::visitCompCond(CompCond *comp_cond)
{
  /* Code For CompCond Goes Here */

  if (comp_cond->attr_1) comp_cond->attr_1->accept(this);
  	std::string attr1 = str;
  if (comp_cond->exp_) comp_cond->exp_->accept(this);
  	std::function<exp_fun> calc_fun = e_fun;
  if (comp_cond->attr_2) comp_cond->attr_2->accept(this);
  	std::string attr2 = str;
  if (comp_cond->compop_) comp_cond->compop_->accept(this);
  if (comp_cond->num_) comp_cond->num_->accept(this);
	if (output == 'i') {
		int num = integer;
		std::function<int_fun> comp_fun = i_fun;
		std::function<condfun> cfun = [=, this] (PhysAttrMap t1, PhysAttrMap t2) {
			return (comp_fun(num, abs ((int)(calc_fun(t1.getVal(attr1), t2.getVal(attr2))))));	
		};
		int_acts.back().addCondFun(cfun);
	} else if (output == 'd') {
		int num = dub;
		std::function<dub_fun> comp_fun = d_fun;
		std::function<condfun> cfun = [=, this] (PhysAttrMap t1, PhysAttrMap t2) {
			return (comp_fun(num, abs ((double)(calc_fun(t1.getVal(attr1), t2.getVal(attr2))))));	
		};
		dub_acts.back().addCondFun(cfun);
	}

}

void ActionBuilder::visitValueCond(ValueCond *value_cond)
{
  /* Code For ValueCond Goes Here */

  if (value_cond->attr_) value_cond->attr_->accept(this);
  std::string attr = str;
  if (value_cond->compop_) value_cond->compop_->accept(this);
  if (value_cond->num_) value_cond->num_->accept(this);
	if (output == 'i') {
		std::function<int_fun> comp_fun = i_fun;
		int num = integer;
		std::function<condfun> cfun = [=, this] (PhysAttrMap t1, PhysAttrMap t2) {
			return (comp_fun(num, t2.getVal(attr).getI()));	
		};
		int_acts.back().addCondFun(cfun);
	} else if (output == 'd') {
		std::function<dub_fun> comp_fun = d_fun;
		double num = integer;
		std::function<condfun> cfun = [=, this] (PhysAttrMap t1, PhysAttrMap t2) {
			return (comp_fun(num, t2.getVal(attr).getD()));	
		};
		dub_acts.back().addCondFun(cfun);
	}
}

void ActionBuilder::visitBoolCond(BoolCond *bool_cond)
{
  /* Code For BoolCond Goes Here */

  if (bool_cond->bool_) bool_cond->bool_->accept(this);
  	bool cur_bool = boolean;
  	std::function<condfun> cfun = [=, this] (PhysAttrMap t1, PhysAttrMap t2) {
		return cur_bool;
	};
	if (output == 'i') {
		int_acts.back().addCondFun(cfun);
	} else if (output == 'd') {
		dub_acts.back().addCondFun(cfun);
	}
	
}

void ActionBuilder::visitAttrCond(AttrCond *attr_cond)
{
  /* Code For AttrCond Goes Here */

  if (attr_cond->attr_) attr_cond->attr_->accept(this);
  std::string attr = str;
  	std::function<condfun> cfun = [=, this] (PhysAttrMap t1, PhysAttrMap t2) {
		return t1.getVal(attr);
	};
	if (output == 'i') {
		int_acts.back().addCondFun(cfun);
	} else if (output == 'd') {
		dub_acts.back().addCondFun(cfun);
	}

}

void ActionBuilder::visitEAttr(EAttr *e_attr)
{
  /* Code For EAttr Goes Here */

  visitString(e_attr->string_);

}

void ActionBuilder::visitEq(Eq *eq)
{
  /* Code For Eq Goes Here */
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i == v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i == v;
		};
	}
}

void ActionBuilder::visitNEq(NEq *n_eq)
{
  /* Code For NEq Goes Here */
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i != v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i != v;
		};
	}
}

void ActionBuilder::visitGt(Gt *gt)
{
  /* Code For Gt Goes Here */
	//Reversed because the second argument represents the input, while the first the number, but in the
	//syntax its the opposite.
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i < v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i < v;
		};
	}


}

void ActionBuilder::visitLt(Lt *lt)
{
  /* Code For Lt Goes Here */
	//Reversed because the second argument represents the input, while the first the number, but in the
	//syntax its the opposite.
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i > v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i > v;
		};
	}


}

void ActionBuilder::visitGte(Gte *gte)
{
  /* Code For Gte Goes Here */
	//Reversed because the second argument represents the input, while the first the number, but in the
	//syntax its the opposite.
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i <= v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i <= v;
		};
	}


}

void ActionBuilder::visitLte(Lte *lte)
{
  /* Code For Lte Goes Here */
	//Reversed because the second argument represents the input, while the first the number, but in the
	//syntax its the opposite.
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i >= v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i >= v;
		};
	}


}

void ActionBuilder::visitAnd(And *and_)
{
  /* Code For And Goes Here */


}

void ActionBuilder::visitOr(Or *or_)
{
  /* Code For Or Goes Here */


}

void ActionBuilder::visitCInt(CInt *c_int)
{
  /* Code For CInt Goes Here */

  visitInteger(c_int->integer_);

}

void ActionBuilder::visitCDouble(CDouble *c_double)
{
  /* Code For CDouble Goes Here */

  visitDouble(c_double->double_);

}

void ActionBuilder::visitESub(ESub *e_sub)
{
  /* Code For ESub Goes Here */
	e_fun = [] (const ExValContainer& a, const ExValContainer& b) -> ExValContainer {
		return a - b;		
	};

}

void ActionBuilder::visitEPlus(EPlus *e_plus)
{
  /* Code For EPlus Goes Here */
	e_fun = [] (const ExValContainer& a, const ExValContainer& b) -> ExValContainer {
		return a + b;		
	};


}

void ActionBuilder::visitSMul(SMul *s_mul)
{
  /* Code For SMul Goes Here */
	if (output == 'i') {
		i_link = [] (int i, const ExValContainer& v) {
			return i * v;
		};
	} else if (output == 'd') {
		d_link = [] (double i, const ExValContainer& v) {
			return i * v;
		};
	}
}

void ActionBuilder::visitVTrue(VTrue *v_true)
{
  /* Code For VTrue Goes Here */
	boolean = true;

}

void ActionBuilder::visitVFalse(VFalse *v_false)
{
  /* Code For VFalse Goes Here */
	boolean = false;

}


void ActionBuilder::visitListAttrDecl(ListAttrDecl *list_attr_decl)
{
  for (ListAttrDecl::iterator i = list_attr_decl->begin() ; i != list_attr_decl->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void ActionBuilder::visitListIStr(ListIStr *list_i_str)
{
  for (ListIStr::iterator i = list_i_str->begin() ; i != list_i_str->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void ActionBuilder::visitListAct(ListAct *list_act)
{
  for (ListAct::iterator i = list_act->begin() ; i != list_act->end() ; ++i)
  {
    (*i)->accept(this);
  }
}


void ActionBuilder::visitInteger(Integer x)
{
  /* Code for Integer Goes Here */
	integer = x;
}

void ActionBuilder::visitChar(Char x)
{
  /* Code for Char Goes Here */
	character = x;
}

void ActionBuilder::visitDouble(Double x)
{
  /* Code for Double Goes Here */
	dub = x;
}

void ActionBuilder::visitString(String x)
{
  /* Code for String Goes Here */
	str = x;
}

void ActionBuilder::visitIdent(Ident x)
{
  /* Code for Ident Goes Here */
}

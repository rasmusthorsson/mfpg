/* File generated by the BNF Converter (bnfc 2.9.5). */

/*** Visitor Design Pattern InstrumentBuilder. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "InstrumentBuilder.h"

#include <iostream>
#include <memory>
#include <set>

extern int TUPLESIZE;
extern std::string ATTRIBUTE_TYPES;
extern std::vector<std::string> ATTRIBUTES;
extern std::set<std::string> DEFINITIVES;

//Entry point for the instrument builder.
void InstrumentBuilder::visitInput(Input *t) {
	t->accept(this);
} 

void InstrumentBuilder::visitOutput(Output *t) {} //abstract class
void InstrumentBuilder::visitAttrDecl(AttrDecl *t) {} //abstract class
void InstrumentBuilder::visitIStr(IStr *t) {} //abstract class
void InstrumentBuilder::visitSPos(SPos *t) {} //abstract class
void InstrumentBuilder::visitNoteDef(NoteDef *t) {} //abstract class
void InstrumentBuilder::visitNoteDefBase(NoteDefBase *t) {} //abstract class
void InstrumentBuilder::visitRestDefBase(RestDefBase *t) {} //abstract class
void InstrumentBuilder::visitAttrType(AttrType *t) {} //abstract class
void InstrumentBuilder::visitDurationDefBase(DurationDefBase *t) {} //abstract class
void InstrumentBuilder::visitAct(Act *t) {} //abstract class
void InstrumentBuilder::visitActionName(ActionName *t) {} //abstract class
void InstrumentBuilder::visitDFun(DFun *t) {} //abstract class
void InstrumentBuilder::visitDep(Dep *t) {} //abstract class
void InstrumentBuilder::visitCFun(CFun *t) {} //abstract class
void InstrumentBuilder::visitAttr(Attr *t) {} //abstract class
void InstrumentBuilder::visitCompOp(CompOp *t) {} //abstract class
void InstrumentBuilder::visitBoolOp(BoolOp *t) {} //abstract class
void InstrumentBuilder::visitNum(Num *t) {} //abstract class
void InstrumentBuilder::visitCNoteDef(CNoteDef *t) {} //abstract class
void InstrumentBuilder::visitCDurationDef(CDurationDef *t) {} //abstract class
void InstrumentBuilder::visitExp(Exp *t) {} //abstract class
void InstrumentBuilder::visitScale(Scale *t) {} //abstract class
void InstrumentBuilder::visitBool(Bool *t) {} //abstract class

void InstrumentBuilder::visitBInput(BInput *b_input)
{
	std::shared_ptr<ActionSet<int>> a_i(new ActionSet<int>());
	int_set = a_i;
	std::shared_ptr<ActionSet<double>> a_d(new ActionSet<double>());
	dub_set = a_d;
	if (b_input->output_) b_input->output_->accept(this);
	if (b_input->listattrdecl_) b_input->listattrdecl_->accept(this);
	if (b_input->lististr_) b_input->lististr_->accept(this);
	if (b_input->listact_) b_input->listact_->accept(this);
	if (b_input->listdep_) b_input->listdep_->accept(this);
	if (output == 'i') {
		std::shared_ptr<Instrument<int>> i_tmp(new Instrument<int>(strings, int_set));
		i_inst = i_tmp;
	} else if (output == 'd') {
		std::shared_ptr<Instrument<double>> i_tmp(new Instrument<double>(strings, dub_set));
		d_inst = i_tmp;
	}
}

void InstrumentBuilder::visitDOutput(DOutput *d_output)
{
	output = 'd';
}

void InstrumentBuilder::visitIOutput(IOutput *i_output)
{
	output = 'i';
}

void InstrumentBuilder::visitDAttr(DAttr *d_attr)
{
	if (d_attr->attrtype_) d_attr->attrtype_->accept(this);
	if (d_attr->attr_) d_attr->attr_->accept(this);
	attrs.push_back(str);
	TUPLESIZE++;
	ATTRIBUTES.push_back(str);
}

void InstrumentBuilder::visitStringDef(StringDef *string_def)
{
	if (string_def->spos_) string_def->spos_->accept(this);
	int spos = integer;
	if (string_def->notedef_1) string_def->notedef_1->accept(this);
	noteenums::Note first = note;
	if (string_def->notedef_2) string_def->notedef_2->accept(this);
	noteenums::Note second = note;

	IString new_string(spos, first, second);
	strings.push_back(new_string);
}

void InstrumentBuilder::visitISPos(ISPos *is_pos)
{
	visitInteger(is_pos->integer_);
}

void InstrumentBuilder::visitINote(INote *i_note)
{
	visitInteger(i_note->integer_);
}

void InstrumentBuilder::visitNNote(NNote *n_note)
{
	visitInteger(n_note->integer_);
	if (n_note->notedefbase_) n_note->notedefbase_->accept(this);
}

void InstrumentBuilder::visitNoteDefBase_A(NoteDefBase_A *notedef_base_a)
{
	note = static_cast<noteenums::Note>(9 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_As(NoteDefBase_As *notedef_base_as)
{
	note = static_cast<noteenums::Note>(10 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_B(NoteDefBase_B *notedef_base_b)
{
	note = static_cast<noteenums::Note>(11 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_C(NoteDefBase_C *notedef_base_c)
{
	note = static_cast<noteenums::Note>(0 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_Cs(NoteDefBase_Cs *notedef_base_cs)
{
	note = static_cast<noteenums::Note>(1 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_D(NoteDefBase_D *notedef_base_d)
{
	note = static_cast<noteenums::Note>(2 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_Ds(NoteDefBase_Ds *notedef_base_ds)
{
	note = static_cast<noteenums::Note>(3 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_E(NoteDefBase_E *notedef_base_e)
{
	note = static_cast<noteenums::Note>(4 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_F(NoteDefBase_F *notedef_base_f)
{
	note = static_cast<noteenums::Note>(5 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_Fs(NoteDefBase_Fs *notedef_base_fs)
{
	note = static_cast<noteenums::Note>(6 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_G(NoteDefBase_G *notedef_base_g)
{
	note = static_cast<noteenums::Note>(7 + (12 * integer));
}

void InstrumentBuilder::visitNoteDefBase_Gs(NoteDefBase_Gs *notedef_base_gs)
{
	note = static_cast<noteenums::Note>(8 + (12 * integer));
}
void InstrumentBuilder::visitRestDefBase_REST(RestDefBase_REST *rest_def_base_rest)
{
	note = noteenums::Note::REST;
}

void InstrumentBuilder::visitAttrType_i(AttrType_i *attr_type_i)
{
	attrtypes += "i";
	ATTRIBUTE_TYPES += "i";
}

void InstrumentBuilder::visitAttrType_d(AttrType_d *attr_type_d)
{
	attrtypes += "d";
	ATTRIBUTE_TYPES += "d";
}

void InstrumentBuilder::visitAttrType_b(AttrType_b *attr_type_b)
{
	attrtypes += "b";
	ATTRIBUTE_TYPES += "b";
}

void InstrumentBuilder::visitDurationDefBase_Double(DurationDefBase_Double *duration_def_base_double)
{
	duration = noteenums::Duration::DoubleDur;
}

void InstrumentBuilder::visitDurationDefBase_Whole(DurationDefBase_Whole *duration_def_base_whole)
{
	duration = noteenums::Duration::Whole;
}

void InstrumentBuilder::visitDurationDefBase_Half(DurationDefBase_Half *duration_def_base_half)
{
	duration = noteenums::Duration::Half;
}

void InstrumentBuilder::visitDurationDefBase_Quarter(DurationDefBase_Quarter *duration_def_base_quarter)
{
	duration = noteenums::Duration::Quarter;
}

void InstrumentBuilder::visitDurationDefBase_Eighth(DurationDefBase_Eighth *duration_def_base_eighth)
{
	duration = noteenums::Duration::Eighth;
}

void InstrumentBuilder::visitDurationDefBase_Sixteenth(DurationDefBase_Sixteenth *duration_def_base_sixteenth)
{
	duration = noteenums::Duration::Sixteenth;
}

void InstrumentBuilder::visitDurationDefBase_ThirtySecond(DurationDefBase_ThirtySecond *duration_def_base_thirty_second)
{
	duration = noteenums::Duration::ThirtySecond;
}

void InstrumentBuilder::visitDurationDefBase_SixtyFourth(DurationDefBase_SixtyFourth *duration_def_base_sixty_fourth)
{
	duration = noteenums::Duration::SixtyFourth;
}

void InstrumentBuilder::visitFunList(FunList *fun_list)
{
	if (fun_list->actionname_) fun_list->actionname_->accept(this);
	std::string action_name = str;
	if (output == 'i') {
		Action<int> a(action_name);
		a_int = a;
	} else if (output == 'd') {
		Action<double> a(action_name);
		a_dub = a;
	}

	acc = ACCUMULATOR::OR;
	if (fun_list->cfun_) fun_list->cfun_->accept(this);
	acc = ACCUMULATOR::PLUS;
	if (fun_list->dfun_) fun_list->dfun_->accept(this);
	if (fun_list->bool_) fun_list->bool_->accept(this);
	bool b = boolean;
	if (output == 'i') {
		Action<int> a = a_int;
		int_set->addAction(a, b);
	} else if (output == 'd') {
		Action<double> a = a_dub;
		dub_set->addAction(a, b);
	}
}

void InstrumentBuilder::visitAName(AName *a_name)
{
	visitIdentifier(a_name->identifier_);
}

void InstrumentBuilder::visitADeps(ADeps *a_deps)
{
	visitIdentifier(a_deps->identifier_1);
	std::string dep1 = str;
	visitIdentifier(a_deps->identifier_2);
	std::string dep2 = str;
	if (a_deps->bool_) a_deps->bool_->accept(this);
	bool adj = boolean;
	if (output == 'i') {
		int_set->addDependency(dep1, dep2, adj);
	} else if (output == 'd') {
		dub_set->addDependency(dep1, dep2, adj);
	}
}

void InstrumentBuilder::visitCombDist(CombDist *comb_dist)
{
	if (comb_dist->dfun_1) comb_dist->dfun_1->accept(this);
	if (comb_dist->exp_) comb_dist->exp_->accept(this);
	ACCUMULATOR tmp_acc = acc;
	if (comb_dist->dfun_2) comb_dist->dfun_2->accept(this);
}

void InstrumentBuilder::visitScaledDist(ScaledDist *scaled_dist)
{
	ACCUMULATOR tmp_acc = acc;
	if (scaled_dist->attr_1) scaled_dist->attr_1->accept(this);
	std::string attr1 = str;
	if (scaled_dist->exp_) scaled_dist->exp_->accept(this);
	if (scaled_dist->attr_2) scaled_dist->attr_2->accept(this);
	std::string attr2 = str;
	if (scaled_dist->scale_) scaled_dist->scale_->accept(this);
	std::function<exp_fun> scale = e_fun;
	if (scaled_dist->num_) scaled_dist->num_->accept(this);
	if (output == 'i') {
		int num = integer;
		std::function<int_link> current_link = i_link;
		std::function<distfun_int> dfun = [=, this](NoteAttributes t1, NoteAttributes t2) -> int {
			return (current_link(num, (abs ((int) scale(t1.getPhysAttr().getVal(attr1), t2.getPhysAttr().getVal(attr2))))));	
		};
		a_int.addDistFun(dfun, tmp_acc);
	} else if (output == 'd') {
		std::function<dub_link> current_link = d_link;
		int num = dub;
		std::function<distfun_dub> dfun = [=, this](NoteAttributes t1, NoteAttributes t2) -> double {
			return (current_link(num, (abs ((double) scale(t1.getPhysAttr().getVal(attr1), t2.getPhysAttr().getVal(attr2))))));	
		};
		a_dub.addDistFun(dfun, tmp_acc);
	}
}

void InstrumentBuilder::visitDirectDist(DirectDist *direct_dist)
{
	ACCUMULATOR tmp_acc = acc;
	if (direct_dist->attr_1) direct_dist->attr_1->accept(this);
	std::string attr1 = str;
	if (direct_dist->attr_2) direct_dist->attr_2->accept(this);
	std::string attr2 = str; 
	if (direct_dist->exp_) direct_dist->exp_->accept(this);
	std::function<exp_fun> current_e_fun = e_fun;
	if (output == 'i') {
		std::function<distfun_int> dfun = [=, this](NoteAttributes t1, NoteAttributes t2) -> int {
			return (abs ((int) current_e_fun(t1.getPhysAttr().getVal(attr1), t2.getPhysAttr().getVal(attr2))));	
		};
		a_int.addDistFun(dfun, tmp_acc);
	} else if (output == 'd') {
		std::function<distfun_dub> dfun = [=, this](NoteAttributes t1, NoteAttributes t2) -> double {
			return (abs ((double) current_e_fun(t1.getPhysAttr().getVal(attr1), t2.getPhysAttr().getVal(attr2))));	
		};
		a_dub.addDistFun(dfun, tmp_acc);
	}
}

void InstrumentBuilder::visitConstDist(ConstDist *const_dist)
{
	ACCUMULATOR tmp_acc = acc;
	if (const_dist->num_) const_dist->num_->accept(this);
	if (output == 'i') {
		int num = integer;
		std::function<distfun_int> dfun = [=, this](NoteAttributes t1, NoteAttributes t2) -> int {
			return num;	
		};
		a_int.addDistFun(dfun, tmp_acc);
	} else if (output == 'd') {
		double num = dub;
		std::function<distfun_dub> dfun = [=, this](NoteAttributes t1, NoteAttributes t2) -> double {
			return num;	
		};
		a_dub.addDistFun(dfun, tmp_acc);
	}
}

void InstrumentBuilder::visitCombCond(CombCond *comb_cond)
{
	if (comb_cond->cfun_1) comb_cond->cfun_1->accept(this);
	if (comb_cond->boolop_) comb_cond->boolop_->accept(this);
	ACCUMULATOR tmp_acc = acc;
	if (comb_cond->cfun_2) comb_cond->cfun_2->accept(this);
}

void InstrumentBuilder::visitCompCond(CompCond *comp_cond)
{
	ACCUMULATOR tmp_acc = acc;
	if (comp_cond->attr_1) comp_cond->attr_1->accept(this);
	std::string attr1 = str;
	if (comp_cond->exp_) comp_cond->exp_->accept(this);
	std::function<exp_fun> calc_fun = e_fun;
	if (comp_cond->attr_2) comp_cond->attr_2->accept(this);
	std::string attr2 = str;
	if (comp_cond->compop_) comp_cond->compop_->accept(this);
	if (comp_cond->num_) comp_cond->num_->accept(this);
	if (output == 'i') {
		int num = integer;
		std::function<int_fun> comp_fun = i_fun;
		std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
			if (attr1 == "NOTE") {
				return (comp_fun(num, abs ((int)(calc_fun(
						ExValContainer((int)t1.getNote()), 
						ExValContainer((int)t2.getNote()))))));
			}
			if (attr1 == "DURATION") {
				return (comp_fun(num, abs ((int)(calc_fun(
						ExValContainer((int)t1.getDuration()), 
						ExValContainer((int)t2.getDuration()))))));
			}
			return (comp_fun(num, abs ((int)(calc_fun(t1.getPhysAttr().getVal(attr1), 
								  t2.getPhysAttr().getVal(attr2))))));
		};
		a_int.addCondFun(cfun, tmp_acc);
	} else if (output == 'd') {
		int num = dub;
		std::function<dub_fun> comp_fun = d_fun;
		std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
			if (attr1 == "NOTE") {
				return (comp_fun(num, abs ((double)(calc_fun(
						ExValContainer((double)t1.getNote()), 
						ExValContainer((double)t2.getNote()))))));
			} 
			if (attr1 == "DURATION") {
				return (comp_fun(num, abs ((double)(calc_fun(
						ExValContainer((double)t1.getDuration()), 
						ExValContainer((double)t2.getDuration()))))));
			}
			return (comp_fun(num, abs ((double)(calc_fun(t1.getPhysAttr().getVal(attr1), t2.getPhysAttr().getVal(attr2))))));
		};
		a_dub.addCondFun(cfun, tmp_acc);
	}
}

void InstrumentBuilder::visitFrValueCond(FrValueCond *fr_value_cond)
{
	ACCUMULATOR tmp_acc = acc;
	if (fr_value_cond->attr_) fr_value_cond->attr_->accept(this);
	std::string attr = str;
	if (fr_value_cond->compop_) fr_value_cond->compop_->accept(this);
	if (fr_value_cond->num_) fr_value_cond->num_->accept(this);
	if (output == 'i') {
		std::function<int_fun> comp_fun = i_fun;
		int num = integer;
		std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
			if (attr == "NOTE") {
				return (comp_fun(num, ExValContainer((int)t1.getNote())));
			}
			if (attr == "DURATION") {
				return (comp_fun(num, ExValContainer((int)t1.getDuration())));
			}
			return (comp_fun(num, t1.getPhysAttr().getVal(attr).getI()));	
		};
		a_int.addCondFun(cfun, tmp_acc);
	} else if (output == 'd') {
		std::function<dub_fun> comp_fun = d_fun;
		double num = dub;
		std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
			if (attr == "NOTE") {
				return (comp_fun(num, ExValContainer((double)t1.getNote())));
			}
			if (attr == "DURATION") {
				return (comp_fun(num, ExValContainer((double)t1.getDuration())));
			}
			return (comp_fun(num, t1.getPhysAttr().getVal(attr).getD()));	
		};
		a_dub.addCondFun(cfun, tmp_acc);
	}
}

void InstrumentBuilder::visitToValueCond(ToValueCond *to_value_cond)
{
	ACCUMULATOR tmp_acc = acc;
	if (to_value_cond->attr_) to_value_cond->attr_->accept(this);
	std::string attr = str;
	if (to_value_cond->compop_) to_value_cond->compop_->accept(this);
	if (to_value_cond->num_) to_value_cond->num_->accept(this);
	if (output == 'i') {
		std::function<int_fun> comp_fun = i_fun;
		int num = integer;
		std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
			if (attr == "NOTE") {
				return (comp_fun(num, ExValContainer((int)t2.getNote())));
			}
			if (attr == "DURATION") {
				return (comp_fun(num, ExValContainer((int)t2.getDuration())));
			}
			return (comp_fun(num, t2.getPhysAttr().getVal(attr).getI()));	
		};
		a_int.addCondFun(cfun, tmp_acc);
	} else if (output == 'd') {
		std::function<dub_fun> comp_fun = d_fun;
		double num = dub;
		std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
			if (attr == "NOTE") {
				return (comp_fun(num, ExValContainer((double)t2.getNote())));
			}
			if (attr == "DURATION") {
				return (comp_fun(num, ExValContainer((double)t2.getDuration())));
			}
			return (comp_fun(num, t2.getPhysAttr().getVal(attr).getD()));	
		};
		a_dub.addCondFun(cfun, tmp_acc);
	}
}

void InstrumentBuilder::visitBoolCond(BoolCond *bool_cond)
{
	ACCUMULATOR tmp_acc = acc;
	if (bool_cond->bool_) bool_cond->bool_->accept(this);
	bool cur_bool = boolean;
	std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
		return cur_bool;
	};
	if (output == 'i') {
		a_int.addCondFun(cfun, tmp_acc);
	} else if (output == 'd') {
		a_dub.addCondFun(cfun, tmp_acc);
	}
}

void InstrumentBuilder::visitFrAttrCond(FrAttrCond *fr_attr_cond)
{
	ACCUMULATOR tmp_acc = acc;
	if (fr_attr_cond->attr_) fr_attr_cond->attr_->accept(this);
	std::string attr = str;
	std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
		//Only primitives that are booleans should be applicable here
		/*
		if (attr == "NOTE") {
			return ExValContainer(true);
		}
		if (attr == "DURATION") {
			return ExValContainer(true);
		}
		*/
		return t1.getPhysAttr().getVal(attr);
	};
	if (output == 'i') {
		a_int.addCondFun(cfun, tmp_acc);
	} else if (output == 'd') {
		a_dub.addCondFun(cfun, tmp_acc);
	}
}

void InstrumentBuilder::visitToAttrCond(ToAttrCond *to_attr_cond)
{
	ACCUMULATOR tmp_acc = acc;
	if (to_attr_cond->attr_) to_attr_cond->attr_->accept(this);
	std::string attr = str;
	std::function<condfun> cfun = [=, this] (NoteAttributes t1, NoteAttributes t2) {
		//Only primitives that are booleans should be applicable here
		/*
		if (attr == "NOTE") {
			return ExValContainer(true);
		}
		if (attr == "DURATION") {
			return ExValContainer(true);
		}
		*/
		return t2.getPhysAttr().getVal(attr);
	};
	if (output == 'i') {
		a_int.addCondFun(cfun, tmp_acc);
	} else if (output == 'd') {
		a_dub.addCondFun(cfun, tmp_acc);
	}
}

void InstrumentBuilder::visitEAttr(EAttr *e_attr)
{
	visitIdentifier(e_attr->identifier_);
}

void InstrumentBuilder::visitEq(Eq *eq)
{
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i == v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i == v;
		};
	}
}

void InstrumentBuilder::visitNEq(NEq *n_eq)
{
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i != v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i != v;
		};
	}
}

void InstrumentBuilder::visitGt(Gt *gt)
{
	//Reversed because the second argument represents the input, while the first the number, but in the
	//syntax its the opposite.
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i < v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i < v;
		};
	}
}

void InstrumentBuilder::visitLt(Lt *lt)
{
	//Reversed because the second argument represents the input, while the first the number, but in the
	//syntax its the opposite.
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i > v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i > v;
		};
	}
}

void InstrumentBuilder::visitGte(Gte *gte)
{
	//Reversed because the second argument represents the input, while the first the number, but in the
	//syntax its the opposite.
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i <= v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i <= v;
		};
	}
}

void InstrumentBuilder::visitLte(Lte *lte)
{
	//Reversed because the second argument represents the input, while the first the number, but in the
	//syntax its the opposite.
	if (output == 'i') {
		i_fun = [] (int i, int v) {
			return i >= v;
		};
	} else if (output == 'd') {
		d_fun = [] (double i, double v) {
			return i >= v;
		};
	}
}

void InstrumentBuilder::visitAnd(And *and_)
{
	acc = ACCUMULATOR::AND;
}

void InstrumentBuilder::visitOr(Or *or_)
{
	acc = ACCUMULATOR::OR;
}

void InstrumentBuilder::visitCInt(CInt *c_int)
{
	visitInteger(c_int->integer_);
}

void InstrumentBuilder::visitCDouble(CDouble *c_double)
{
	visitDouble(c_double->double_);
}

void InstrumentBuilder::visitCNote(CNote *c_note)
{
	if (c_note->cnotedef_) c_note->cnotedef_->accept(this);
	integer = static_cast<int>(note);
}

void InstrumentBuilder::visitCDuration(CDuration *c_duration)
{
	if (c_duration->cdurationdef_) c_duration->cdurationdef_->accept(this);
	integer = (int)duration;
}
void InstrumentBuilder::visitCNRestNote(CNRestNote *cn_rest_note)
{
  if (cn_rest_note->restdefbase_) cn_rest_note->restdefbase_->accept(this);
}

void InstrumentBuilder::visitCNNote(CNNote *cn_note)
{
  visitInteger(cn_note->integer_);
  if (cn_note->notedefbase_) cn_note->notedefbase_->accept(this);
}

void InstrumentBuilder::visitCNDuration(CNDuration *cn_duration)
{
  if (cn_duration->durationdefbase_) cn_duration->durationdefbase_->accept(this);
}

void InstrumentBuilder::visitESub(ESub *e_sub)
{
	acc = ACCUMULATOR::MINUS;
	if (output == 'i') {
		e_fun = [] (const ExValContainer& a, const ExValContainer& b) -> ExValContainer {
			return abs((int)(a - b));		
		};
	} else if (output == 'd') {
		e_fun = [] (const ExValContainer& a, const ExValContainer& b) -> ExValContainer {
			return abs((double)(a - b));		
		};
	}
}

void InstrumentBuilder::visitEPlus(EPlus *e_plus)
{
	acc = ACCUMULATOR::PLUS;
	e_fun = [] (const ExValContainer& a, const ExValContainer& b) -> ExValContainer {
		return a + b;		
	};
}

void InstrumentBuilder::visitSMul(SMul *s_mul)
{
	if (output == 'i') {
		i_link = [] (int i, const ExValContainer& v) {
			return i * v;
		};
	} else if (output == 'd') {
		d_link = [] (double i, const ExValContainer& v) {
			return i * v;
		};
	}
}

void InstrumentBuilder::visitVTrue(VTrue *v_true)
{
	boolean = true;
}

void InstrumentBuilder::visitVFalse(VFalse *v_false)
{
	boolean = false;
}


void InstrumentBuilder::visitListAttrDecl(ListAttrDecl *list_attr_decl)
{
	for (ListAttrDecl::iterator i = list_attr_decl->begin() ; i != list_attr_decl->end() ; ++i) {
		(*i)->accept(this);
	}
}

void InstrumentBuilder::visitListIStr(ListIStr *list_i_str)
{
	for (ListIStr::iterator i = list_i_str->begin() ; i != list_i_str->end() ; ++i) {
		(*i)->accept(this);
	}
}

void InstrumentBuilder::visitListAct(ListAct *list_act)
{
	for (ListAct::iterator i = list_act->begin() ; i != list_act->end() ; ++i) {
		(*i)->accept(this);
	}
}

void InstrumentBuilder::visitListDep(ListDep *list_dep)
{
	for (ListDep::iterator i = list_dep->begin() ; i != list_dep->end() ; ++i) {
		(*i)->accept(this);
	}
}

void InstrumentBuilder::visitInteger(Integer x)
{
	integer = x;
}

void InstrumentBuilder::visitChar(Char x)
{
	character = x;
}

void InstrumentBuilder::visitDouble(Double x)
{
	dub = x;
}

void InstrumentBuilder::visitString(String x)
{
	str = x;
}

void InstrumentBuilder::visitIdent(Ident x)
{
  /* Code for Ident Goes Here */
}

void InstrumentBuilder::visitIdentifier(Identifier x)
{
	std::string t(x);
	str = t;
  /* Code for Identifier Goes Here */
}

